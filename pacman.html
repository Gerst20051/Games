<!--
 ::::::::  :::::::::  ::::::::::     ::: ::::::::::: :::::::::: :::::::::       :::::::::  :::   :::
:+:    :+: :+:    :+: :+:          :+: :+:   :+:     :+:        :+:    :+:      :+:    :+: :+:   :+: :+:
+:+        +:+    +:+ +:+         +:+   +:+  +:+     +:+        +:+    +:+      +:+    +:+  +:+ +:+
+#+        +#++:++#:  +#++:++#   +#++:++#++: +#+     +#++:++#   +#+    +:+      +#++:++#+    +#++:
+#+        +#+    +#+ +#+        +#+     +#+ +#+     +#+        +#+    +#+      +#+    +#+    +#+
#+#    #+# #+#    #+# #+#        #+#     #+# #+#     #+#        #+#    #+#      #+#    #+#    #+#    #+#
 ########  ###    ### ########## ###     ### ###     ########## #########       #########     ###



	:::     ::::    ::: :::::::::  :::::::::  :::::::::: :::       :::       ::::::::  :::::::::: :::::::::   :::::::: :::::::::::
  :+: :+:   :+:+:   :+: :+:    :+: :+:    :+: :+:        :+:       :+:      :+:    :+: :+:        :+:    :+: :+:    :+:    :+:
 +:+   +:+  :+:+:+  +:+ +:+    +:+ +:+    +:+ +:+        +:+       +:+      +:+        +:+        +:+    +:+ +:+           +:+
+#++:++#++: +#+ +:+ +#+ +#+    +:+ +#++:++#:  +#++:++#   +#+  +:+  +#+      :#:        +#++:++#   +#++:++#:  +#++:++#++    +#+
+#+     +#+ +#+  +#+#+# +#+    +#+ +#+    +#+ +#+        +#+ +#+#+ +#+      +#+   +#+# +#+        +#+    +#+        +#+    +#+
#+#     #+# #+#   #+#+# #+#    #+# #+#    #+# #+#         #+#+# #+#+#       #+#    #+# #+#        #+#    #+# #+#    #+#    #+#
###     ### ###    #### #########  ###    ### ##########   ###   ###         ########  ########## ###    ###  ########     ###
-->
<!DOCTYPE html><html><head><meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>Pac-Man (via Canvas Engine)</title>
<script src="canvasengine.js"></script>
<style>
body {
	margin: 0;
	overflow: hidden;
	padding: 0;
}

#canvaspane {
	cursor: default;
}
</style>
</head>
<body>
<div id="content">
<div id="canvaspane">
<canvas id="canvas1" width="100" height="100"></canvas>
</div>
</div>
<script>
'use strict';

var gameObjects = [],
	pacman,
	mainScene,
	ghosts,
	blockHeight,
	blockWidth,
	levelWon = false,
	gameOver = false,
	isPaused = false,
	numGhosts = 4,
	eatenGhosts = 0,
	numLivesRemaining = 3,
	currentMazeLevel = 0,
	doFullScreen = true,
	mapSize = {
		height: (doFullScreen) ? maxHeight : 500,
		width: (doFullScreen) ? maxWidth : 800
	},
	initialTouchX = 0,
	initialTouchY = 0,
	finalTouchX = 0,
	finalTouchY = 0,
	pendingGhostRespawns = [];

// block types
var VOID = 0,
	WALL = 1,
	PATH = 2,
	PASS = 3, // PASSAGE (NO FOOD)
	CAGE = 4,
	DOOR = 5,
	PORT = 6; // TUNNEL

// object types
var PACMAN = 1,
	GHOST = 2,
	FOOD = 3,
	PILL = 4;

// ghost types
var RED = 1,    // shadow / blinky
	PINK = 2,   // speedy / pinky
	BLUE = 3,   // bashful / inky
	ORANGE = 4; // inky / clyde

var ghostRankings = [
	RED,
	PINK,
	BLUE,
	ORANGE
];

var ghostExitDelay = {
	[RED]: 0,    // leaves first
	[PINK]: 2,   // slight delay
	[BLUE]: 4,   // moderate delay
	[ORANGE]: 6, // longest delay
};

// movement directions
var NO_DIRECTION = 0,
	LEFT = -1,
	UP = -2,
	RIGHT = 1,
	DOWN = 2;

var level_0 = {
	maze: [
		[ WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL ],
		[ WALL, PATH, PATH, PATH, PATH, PATH, PATH, PATH, WALL ],
		[ WALL, PATH, WALL, WALL, DOOR, WALL, WALL, PATH, WALL ],
		[ WALL, PATH, WALL, CAGE, CAGE, CAGE, WALL, PATH, WALL ],
		[ WALL, PATH, WALL, CAGE, CAGE, CAGE, WALL, PATH, WALL ],
		[ WALL, PATH, WALL, WALL, WALL, WALL, WALL, PATH, WALL ],
		[ WALL, PATH, PATH, PATH, PATH, PATH, PATH, PATH, WALL ],
		[ WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL ]
	],
	pills: [
		// [row, column]
		[1, 1],
		[1, 7],
		[6, 1],
		[6, 7]
	],
	food: [
		// [row, column]
		[1, 4],
		[3, 1],
		[3, 7],
		[4, 1],
		[4, 7],
		[6, 4]
	]
};

var level_1 = {
	maze: [
		[ WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL ],
		[ WALL, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, WALL, WALL, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, WALL ],
		[ WALL, PATH, WALL, WALL, WALL, WALL, PATH, WALL, WALL, WALL, WALL, WALL, PATH, WALL, WALL, PATH, WALL, WALL, WALL, WALL, WALL, PATH, WALL, WALL, WALL, WALL, PATH, WALL ],
		[ WALL, PATH, WALL, WALL, WALL, WALL, PATH, WALL, WALL, WALL, WALL, WALL, PATH, WALL, WALL, PATH, WALL, WALL, WALL, WALL, WALL, PATH, WALL, WALL, WALL, WALL, PATH, WALL ],
		[ WALL, PATH, WALL, WALL, WALL, WALL, PATH, WALL, WALL, WALL, WALL, WALL, PATH, WALL, WALL, PATH, WALL, WALL, WALL, WALL, WALL, PATH, WALL, WALL, WALL, WALL, PATH, WALL ],
		[ WALL, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, WALL ],
		[ WALL, PATH, WALL, WALL, WALL, WALL, PATH, WALL, WALL, PATH, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, PATH, WALL, WALL, PATH, WALL, WALL, WALL, WALL, PATH, WALL ],
		[ WALL, PATH, WALL, WALL, WALL, WALL, PATH, WALL, WALL, PATH, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, PATH, WALL, WALL, PATH, WALL, WALL, WALL, WALL, PATH, WALL ],
		[ WALL, PATH, PATH, PATH, PATH, PATH, PATH, WALL, WALL, PATH, PATH, PATH, PATH, WALL, WALL, PATH, PATH, PATH, PATH, WALL, WALL, PATH, PATH, PATH, PATH, PATH, PATH, WALL ],
		[ WALL, WALL, WALL, WALL, WALL, WALL, PATH, WALL, WALL, WALL, WALL, WALL, PASS, WALL, WALL, PASS, WALL, WALL, WALL, WALL, WALL, PATH, WALL, WALL, WALL, WALL, WALL, WALL ],
		[ VOID, VOID, VOID, VOID, VOID, WALL, PATH, WALL, WALL, WALL, WALL, WALL, PASS, WALL, WALL, PASS, WALL, WALL, WALL, WALL, WALL, PATH, WALL, VOID, VOID, VOID, VOID, VOID ],
		[ VOID, VOID, VOID, VOID, VOID, WALL, PATH, WALL, WALL, PASS, PASS, PASS, PASS, PASS, PASS, PASS, PASS, PASS, PASS, WALL, WALL, PATH, WALL, VOID, VOID, VOID, VOID, VOID ],
		[ VOID, VOID, VOID, VOID, VOID, WALL, PATH, WALL, WALL, PASS, WALL, WALL, WALL, DOOR, DOOR, WALL, WALL, WALL, PASS, WALL, WALL, PATH, WALL, VOID, VOID, VOID, VOID, VOID ],
		[ WALL, WALL, WALL, WALL, WALL, WALL, PATH, WALL, WALL, PASS, WALL, CAGE, CAGE, CAGE, CAGE, CAGE, CAGE, WALL, PASS, WALL, WALL, PATH, WALL, WALL, WALL, WALL, WALL, WALL ],
		[ PORT, PASS, PASS, PASS, PASS, PASS, PATH, PASS, PASS, PASS, WALL, CAGE, CAGE, CAGE, CAGE, CAGE, CAGE, WALL, PASS, PASS, PASS, PATH, PASS, PASS, PASS, PASS, PASS, PORT ],
		[ WALL, WALL, WALL, WALL, WALL, WALL, PATH, WALL, WALL, PASS, WALL, CAGE, CAGE, CAGE, CAGE, CAGE, CAGE, WALL, PASS, WALL, WALL, PATH, WALL, WALL, WALL, WALL, WALL, WALL ],
		[ VOID, VOID, VOID, VOID, VOID, WALL, PATH, WALL, WALL, PASS, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, PASS, WALL, WALL, PATH, WALL, VOID, VOID, VOID, VOID, VOID ],
		[ VOID, VOID, VOID, VOID, VOID, WALL, PATH, WALL, WALL, PASS, PASS, PASS, PASS, PASS, PASS, PASS, PASS, PASS, PASS, WALL, WALL, PATH, WALL, VOID, VOID, VOID, VOID, VOID ],
		[ VOID, VOID, VOID, VOID, VOID, WALL, PATH, WALL, WALL, PASS, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, PASS, WALL, WALL, PATH, WALL, VOID, VOID, VOID, VOID, VOID ],
		[ WALL, WALL, WALL, WALL, WALL, WALL, PATH, WALL, WALL, PASS, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, PASS, WALL, WALL, PATH, WALL, WALL, WALL, WALL, WALL, WALL ],
		[ WALL, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, WALL, WALL, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, WALL ],
		[ WALL, PATH, WALL, WALL, WALL, WALL, PATH, WALL, WALL, WALL, WALL, WALL, PATH, WALL, WALL, PATH, WALL, WALL, WALL, WALL, WALL, PATH, WALL, WALL, WALL, WALL, PATH, WALL ],
		[ WALL, PATH, WALL, WALL, WALL, WALL, PATH, WALL, WALL, WALL, WALL, WALL, PATH, WALL, WALL, PATH, WALL, WALL, WALL, WALL, WALL, PATH, WALL, WALL, WALL, WALL, PATH, WALL ],
		[ WALL, PATH, PATH, PATH, WALL, WALL, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, WALL, WALL, PATH, PATH, PATH, WALL ],
		[ WALL, WALL, WALL, PATH, WALL, WALL, PATH, WALL, WALL, PATH, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, PATH, WALL, WALL, PATH, WALL, WALL, PATH, WALL, WALL, WALL ],
		[ WALL, WALL, WALL, PATH, WALL, WALL, PATH, WALL, WALL, PATH, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, PATH, WALL, WALL, PATH, WALL, WALL, PATH, WALL, WALL, WALL ],
		[ WALL, PATH, PATH, PATH, PATH, PATH, PATH, WALL, WALL, PATH, PATH, PATH, PATH, WALL, WALL, PATH, PATH, PATH, PATH, WALL, WALL, PATH, PATH, PATH, PATH, PATH, PATH, WALL ],
		[ WALL, PATH, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, PATH, WALL, WALL, PATH, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, PATH, WALL ],
		[ WALL, PATH, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, PATH, WALL, WALL, PATH, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, PATH, WALL ],
		[ WALL, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, WALL ],
		[ WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL ],
	],
	pills: [
		// [row, column]
		[3, 1],
		[3, 26],
		[23, 1],
		[23, 26]
	],
	food: []
};

var level_2 = {
	maze: [
		[ WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL ],
		[ WALL, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, WALL ],
		[ WALL, PATH, WALL, WALL, WALL, PATH, WALL, WALL, WALL, WALL, WALL, PATH, WALL, WALL, WALL, PATH, WALL, WALL, WALL, WALL, WALL, PATH, WALL, WALL, WALL, PATH, PATH, WALL ],
		[ WALL, PATH, WALL, PATH, WALL, PATH, WALL, PATH, PATH, PATH, WALL, PATH, WALL, PATH, WALL, PATH, WALL, PATH, PATH, PATH, WALL, PATH, WALL, PATH, WALL, PATH, PATH, WALL ],
		[ WALL, PATH, WALL, PATH, WALL, PATH, WALL, PATH, WALL, PATH, WALL, PATH, WALL, PATH, WALL, PATH, WALL, PATH, WALL, PATH, WALL, PATH, WALL, PATH, WALL, PATH, PATH, WALL ],
		[ WALL, PATH, WALL, PATH, WALL, PATH, WALL, PATH, WALL, PATH, WALL, PATH, WALL, PATH, WALL, PATH, WALL, PATH, WALL, PATH, WALL, PATH, WALL, PATH, WALL, PATH, PATH, WALL ],
		[ WALL, PATH, WALL, PATH, PATH, PATH, WALL, PATH, WALL, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, WALL, PATH, PATH, PATH, WALL, PATH, WALL, PATH, PATH, WALL ],
		[ WALL, PATH, WALL, WALL, WALL, PATH, WALL, PATH, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, PATH, WALL, PATH, WALL, WALL, WALL, PATH, WALL, PATH, PATH, WALL ],
		[ WALL, PATH, PATH, PATH, WALL, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, WALL, PATH, PATH, PATH, PATH, PATH, PATH, WALL ],
		[ WALL, PATH, WALL, PATH, WALL, WALL, WALL, PATH, WALL, WALL, WALL, PATH, WALL, WALL, WALL, PATH, WALL, WALL, WALL, PATH, WALL, WALL, WALL, PATH, WALL, PATH, PATH, WALL ],
		[ WALL, PATH, WALL, PATH, PATH, PATH, WALL, PATH, PATH, PATH, PATH, PATH, WALL, PATH, WALL, PATH, PATH, PATH, WALL, PATH, PATH, PATH, WALL, PATH, WALL, PATH, PATH, WALL ],
		[ WALL, PATH, WALL, WALL, WALL, PATH, WALL, WALL, WALL, WALL, WALL, PATH, WALL, PATH, WALL, PATH, WALL, WALL, WALL, WALL, WALL, PATH, WALL, WALL, WALL, PATH, PATH, WALL ],
		[ WALL, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, WALL ],
		[ WALL, PATH, WALL, WALL, WALL, WALL, WALL, PATH, WALL, WALL, WALL, WALL, WALL, DOOR, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, PATH, WALL, WALL, PATH, WALL ],
		[ WALL, PATH, WALL, PATH, PATH, PATH, WALL, PATH, PATH, PATH, WALL, CAGE, CAGE, CAGE, CAGE, CAGE, CAGE, WALL, WALL, PATH, PATH, PATH, PATH, PATH, PATH, WALL, PATH, WALL ],
		[ WALL, PATH, WALL, PATH, WALL, PATH, WALL, PATH, WALL, WALL, WALL, CAGE, CAGE, CAGE, CAGE, CAGE, CAGE, WALL, WALL, WALL, PATH, WALL, PATH, WALL, PATH, WALL, PATH, WALL ],
		[ WALL, PATH, WALL, PATH, WALL, PATH, WALL, PATH, WALL, PATH, WALL, CAGE, CAGE, CAGE, CAGE, CAGE, CAGE, WALL, WALL, WALL, PATH, WALL, PATH, WALL, PATH, WALL, PATH, WALL ],
		[ WALL, PATH, WALL, PATH, WALL, PATH, WALL, PATH, WALL, PATH, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, WALL ],
		[ WALL, PATH, WALL, PATH, WALL, PATH, WALL, PATH, PATH, PATH, WALL, PATH, WALL, WALL, WALL, PATH, WALL, PATH, PATH, PATH, WALL, PATH, WALL, PATH, WALL, PATH, PATH, WALL ],
		[ WALL, PATH, WALL, PATH, WALL, PATH, WALL, WALL, WALL, PATH, WALL, PATH, WALL, PATH, WALL, PATH, WALL, PATH, WALL, PATH, WALL, PATH, WALL, WALL, WALL, PATH, PATH, WALL ],
		[ WALL, PATH, PATH, PATH, PATH, PATH, PATH, PATH, WALL, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, WALL, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, WALL ],
		[ WALL, PATH, WALL, WALL, WALL, WALL, WALL, PATH, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, PATH, WALL, WALL, WALL, WALL, WALL, PATH, WALL, WALL, PATH, WALL ],
		[ WALL, PATH, PATH, PATH, PATH, PATH, WALL, PATH, PATH, PATH, PATH, PATH, WALL, PATH, PATH, PATH, PATH, PATH, PATH, PATH, WALL, PATH, PATH, PATH, WALL, PATH, PATH, WALL ],
		[ WALL, PATH, WALL, PATH, WALL, PATH, WALL, WALL, WALL, WALL, WALL, PATH, WALL, PATH, WALL, PATH, WALL, WALL, WALL, WALL, WALL, PATH, WALL, PATH, WALL, PATH, PATH, WALL ],
		[ WALL, PATH, WALL, PATH, WALL, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, WALL, PATH, WALL, PATH, PATH, WALL ],
		[ WALL, PATH, WALL, PATH, WALL, WALL, WALL, PATH, WALL, WALL, WALL, PATH, WALL, WALL, WALL, PATH, WALL, WALL, WALL, PATH, WALL, WALL, WALL, PATH, WALL, PATH, PATH, WALL ],
		[ WALL, PATH, PATH, PATH, PATH, PATH, WALL, PATH, PATH, PATH, PATH, PATH, WALL, PATH, WALL, PATH, PATH, PATH, PATH, PATH, WALL, PATH, PATH, PATH, PATH, PATH, PATH, WALL ],
		[ WALL, PATH, WALL, WALL, WALL, PATH, WALL, WALL, WALL, WALL, WALL, PATH, WALL, PATH, WALL, PATH, WALL, WALL, WALL, WALL, WALL, PATH, WALL, WALL, WALL, PATH, PATH, WALL ],
		[ WALL, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, PATH, WALL ],
		[ WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL ]
	],
	pills: [
		// [row, column]
		[1, 1],
		[1, 26],
		[28, 1],
		[28, 26]
	],
	food: []
};

var mazes = [
	level_0.maze,
	level_1.maze,
	level_2.maze
];

var pills = [
	level_0.pills,
	level_1.pills,
	level_2.pills
];

var food = [
	level_0.food,
	level_1.food,
	level_2.food
];

function collidePoint(obj1, obj2, buffer) {
	buffer = buffer || 0;
	if (dist(obj1.getX(), obj1.getY(), obj2.getX(), obj2.getY()) <= obj1.getRadius() + obj2.getRadius() + buffer) {
		return true;
	}
	return false;
}

function collideBlock(obj1, obj2) {
	if (getBlockFromGameObject(obj1).toString() === getBlockFromGameObject(obj2).toString()) {
		return true;
	}
	return false;
}

function scheduleGhostRespawn(ghostType, delaySeconds) {
	pendingGhostRespawns.push({ ghostType, at: timeSeconds() + (delaySeconds || 3) });
}

function processGhostRespawns() {
	if (!pendingGhostRespawns.length) return;
	var now = timeSeconds();
	for (var i = pendingGhostRespawns.length; i--;) {
		if (pendingGhostRespawns[i].at <= now) {
			gameObjects.push(new Ghost(pendingGhostRespawns[i].ghostType));
			pendingGhostRespawns.splice(i, 1);
		}
	}
}

function getBlockDimensions() {
	var currentMaze = mazes[currentMazeLevel];
	blockHeight = mapSize.height / currentMaze.length;
	blockWidth = mapSize.width / currentMaze[0].length;
}

function getBlockFromCoordinates(x, y) {
	var rowIndex = floor(y / blockHeight);
	var columnIndex = floor(x / blockWidth);
	return [rowIndex, columnIndex];
}

function getBlockFromGameObject(gameObject) {
	return getBlockFromCoordinates(gameObject.getX(), gameObject.getY());
}

function getCoordinatesFromBlockIndex(rowIndex, columnIndex) {
	return [blockWidth * columnIndex, blockHeight * rowIndex];
}

function getCenterCoordinatesFromBlockIndex(rowIndex, columnIndex) {
	return [blockWidth * columnIndex + blockWidth / 2, blockHeight * rowIndex + blockHeight / 2];
}

function getCoordinatesOfType(blockType) {
	var eligibleBlocks = [];
	var currentMaze = mazes[currentMazeLevel];
	currentMaze.forEach(function (levelRow, rowIndex) {
		levelRow.forEach(function (rowBlock, columnIndex) {
			if (rowBlock === blockType) {
				eligibleBlocks.push([rowIndex, columnIndex]);
			}
		});
	});
	return eligibleBlocks;
}

function getRandomCoordinateOfType(blockType) {
	var eligibleBlocks = [];
	var currentMaze = mazes[currentMazeLevel];
	currentMaze.forEach(function (levelRow, rowIndex) {
		levelRow.forEach(function (rowBlock, columnIndex) {
			if (rowBlock === blockType) {
				eligibleBlocks.push([rowIndex, columnIndex]);
			}
		});
	});
	if (eligibleBlocks.length) {
		if (blockType === WALL || blockType === DOOR) {
			return getCoordinatesFromBlockIndex.apply(null, randomElement(eligibleBlocks));
		} else {
			return getCenterCoordinatesFromBlockIndex.apply(null, randomElement(eligibleBlocks));
		}
	}
}

function getRealCoordinateToSpawnPacman() {
	var block = getBlockFromCoordinates.apply(null, getRandomCoordinateOfType(DOOR));
	var currentMaze = mazes[currentMazeLevel];
	for (var i = block[0]; i < currentMaze.length; i++) {
		if (currentMaze[i][block[1]] === PASS || currentMaze[i][block[1]] === PATH) {
			return getCenterCoordinatesFromBlockIndex(i, block[1]);
		}
	}
	return getRandomCoordinateToSpawnPacman();
}

function getRandomCoordinateToSpawnPacman() {
	return getRandomCoordinateOfType(PASS) || getRandomCoordinateOfType(PATH);
}

function getRandomCoordinateToSpawnGhost() {
	return getRandomCoordinateOfType(CAGE);
}

function getOppositePortCenterCoordinates(currentRow, currentCol) {
	var ports = getCoordinatesOfType(PORT);
	if (ports.length < 2) {
		return null;
	}
	// Prefer a matching tunnel exit in the same row, farthest by column
	var sameRowPorts = ports.filter(function (p) { return p[0] === currentRow && !(p[0] === currentRow && p[1] === currentCol); });
	var target;
	if (sameRowPorts.length) {
		target = sameRowPorts.reduce(function (best, p) {
			return (!best || Math.abs(p[1] - currentCol) > Math.abs(best[1] - currentCol)) ? p : best;
		}, null);
	}
	// Fallback: choose the farthest by column among all ports
	if (!target) {
		target = ports.reduce(function (best, p) {
			if (p[0] === currentRow && p[1] === currentCol) return best;
			return (!best || Math.abs(p[1] - currentCol) > Math.abs(best[1] - currentCol)) ? p : best;
		}, null);
	}
	if (!target) {
		// mirror across the maze width as a last resort
		var currentMaze = mazes[currentMazeLevel];
		var lastCol = currentMaze[0].length - 1;
		target = [currentRow, lastCol - currentCol];
	}
	return getCenterCoordinatesFromBlockIndex(target[0], target[1]);
}

function getDoorBlockIndex() {
	var doorCoordinate = getRandomCoordinateOfType(DOOR);
	return getBlockFromCoordinates.apply(null, doorCoordinate);
}

function getGameObjectsOfType(objectType) {
	var matches = [];
	gameObjects.forEach(function (gameObject) {
		if (gameObject.type === objectType) {
			matches.push(gameObject);
		}
	});
	return matches;
}

function isPointInsideBoundingBox(pointX, pointY, minX, maxX, minY, maxY) {
	if (minX < pointX && pointX < maxX && minY < pointY && pointY < maxY) {
		return true;
	}
	return false;
}

function GameObject() {
	this.x = 0;
	this.y = 0;
	this.destroy = false;
	this.active = true;
	this.collidable = true;
	this.isColliding = false;
	this.collidableWith = -1;
	this.type = 0;

	this.activate = function () {
		this.active = true;
	};

	this.deactivate = function () {
		this.active = false;
	};

	this.kill = function () {
		this.destroy = true;
	};

	this.isCollidableWith = function (obj) {
		return (
			(this.collidable === true && obj.collidable === true) &&
			(this.collidableWith === obj.type || -1 < this.collidableWith.indexOf(obj.type))
		);
	};

	this.setX = function (newX) {
		this.x = newX;
	};

	this.getX = function () {
		return this.x;
	};

	this.setY = function (newY) {
		this.y = newY;
	};

	this.getY = function () {
		return this.y;
	};

	this.setPosition = function (newX, newY) {
		this.x = newX;
		this.y = newY;
	};

	this.getNearGameObjectsOfType = function (type) {
		var currentBlock = getBlockFromGameObject(this);
		var currentBlockX = currentBlock[1] * blockWidth;
		var currentBlockY = currentBlock[0] * blockHeight;
		var minX = currentBlockX - blockWidth,
			maxX = currentBlockX + (blockWidth * 2),
			minY = currentBlockY - blockHeight,
			maxY = currentBlockY + (blockHeight * 2);
		var nearGameObjects = [];
		gameObjects.forEach(function (gameObject) {
			if (gameObject.type === type && isPointInsideBoundingBox(gameObject.getX(), gameObject.getY(), minX, maxX, minY, maxY)) {
				nearGameObjects.push(gameObject);
			}
		});
		return nearGameObjects;
	};

	this.getNearBlockTypes = function () {
		var currentMaze = mazes[currentMazeLevel];
		var currentBlock = getBlockFromGameObject(this);
		var currentBlockRow = currentBlock[0];
		var currentBlockIndex = currentBlock[1];
		var left = currentMaze[currentBlockRow] && currentMaze[currentBlockRow][currentBlockIndex - 1] || undef;
		var up = currentMaze[currentBlockRow - 1] && currentMaze[currentBlockRow - 1][currentBlockIndex] || undef;
		var right = currentMaze[currentBlockRow] && currentMaze[currentBlockRow][currentBlockIndex + 1] || undef;
		var down = currentMaze[currentBlockRow + 1] && currentMaze[currentBlockRow + 1][currentBlockIndex] || undef;
		return [left, up, right, down];
	};

	this.init = nop;
	this.run = nop;
	this.draw = nop;
}

function MovableGameObject() {
	this.speed = 1;
	this.radius = 1;
	this.dir = NO_DIRECTION;
	this.nextDir = NO_DIRECTION;

	this.moveToCenterOfCurrentBlock = function () {
		var centerCoordinates = getCenterCoordinatesFromBlockIndex.apply(null, getBlockFromGameObject(this));
		this.x = centerCoordinates[0];
		this.y = centerCoordinates[1];
	};

	this.getSpeed = function () {
		return this.speed;
	};

	this.setSpeed = function (newSpeed) {
		this.speed = newSpeed;
	};

	this.getRadius = function () {
		return this.radius;
	};

	this.setRadius = function (newRadius) {
		this.radius = newRadius;
	};

	this.getDir = function () {
		return this.dir;
	};

	this.setDir = function (newDir) {
		this.dir = newDir;
	};

	this.getNextDir = function () {
		return this.nextDir;
	};

	this.setNextDir = function (newNextDir) {
		this.nextDir = newNextDir;
	};

	this.reverseDir = function () {
		this.dir = -this.dir;
		this.prevDir = this.dir;
	};
}

var Pacman = function () {
	this.type = PACMAN;
	this.speed = (min(blockHeight, blockWidth) * 0.8) / 20;
	this.radius = (min(blockHeight, blockWidth) * 0.8) / 2;
	this.mouthRadius = 4;
	this.mouthRadiusIncrement = 1;
	this.maxMouthRadius = 4;
	this.minMouthRadius = 25;
	this.teleportLocked = false; // prevents immediate re-teleport while on PORT tile

	this.init = function (x, y) {
		this.setPosition(x, y);
	};

	this.run = function () {
		if (this.active && !levelWon && !gameOver) {
			var moved = this.move();
			if (moved) {
				this.stepMouth();
			} else {
				this.mouthRadius = this.maxMouthRadius;
			}
		}
	};

	this.draw = function () {
		if (!levelWon && !gameOver) {
			var directionLookup = {
				'-1': PI,
				'-2': -HALF_PI,
				'1': 0,
				'2': HALF_PI
			};
			var mouthAngle = directionLookup[this.dir] || 0;
			fill(colors.yellow);
			engage()
			ctx.arc(pacman.getX(), pacman.getY(), pacman.getRadius(), PI / this.mouthRadius + mouthAngle, -PI / this.mouthRadius + mouthAngle, false);
			ctx.lineTo(pacman.getX(), pacman.getY());
			paint();
		}
	};

	this.move = function () {
		var hasMoved = false;
		if (this.active && (this.dir !== NO_DIRECTION || this.nextDir !== NO_DIRECTION)) {
			// var nearGameObjects = this.getNearGameObjectsOfType(GHOST);
			var nearBlockTypes = this.getNearBlockTypes();
			//  NOTE: getNearBlockTypes() returns an array of block types in the order of LEFT, UP, RIGHT, DOWN -> 0, 1, 2, 3
			//  so we can use the index to get the block type for the direction
			var directionLookup = {
				'-1': 0,
				'-2': 1,
				'1': 2,
				'2': 3
			};
			var nextDirectionIndex = directionLookup[this.nextDir];
			if (-1 < nextDirectionIndex) {
				if ((nearBlockTypes[nextDirectionIndex] === PATH || nearBlockTypes[nextDirectionIndex] === PASS || nearBlockTypes[nextDirectionIndex] === PORT) && this.nextDir !== NO_DIRECTION) {
					this.dir = this.nextDir;
					this.nextDir = NO_DIRECTION;
				}
			}
			var currentDirectionIndex = directionLookup[this.dir];
			if (-1 < currentDirectionIndex) {
				if (nearBlockTypes[currentDirectionIndex] === WALL) {
					this.dir = NO_DIRECTION;
					this.nextDir = NO_DIRECTION;
					this.moveToCenterOfCurrentBlock();
					return hasMoved;
				}
			} else {
				return hasMoved;
			}
			hasMoved = true;
			var centerCoordinates = getCenterCoordinatesFromBlockIndex.apply(null, getBlockFromGameObject(this));
			if (abs(this.dir) === 1) {
				this.x += this.speed * this.dir;
				this.y = centerCoordinates[1];
			} else {
				if (0 < this.dir) {
					this.y += this.speed;
				} else {
					this.y -= this.speed;
				}
				this.x = centerCoordinates[0];
			}

			// Handle teleport on PORT tiles (tunnels)
			var currentBlock = getBlockFromGameObject(this);
			var tile = mazes[currentMazeLevel][currentBlock[0]] && mazes[currentMazeLevel][currentBlock[0]][currentBlock[1]];
			if (tile === PORT) {
				if (!this.teleportLocked) {
					var dest = getOppositePortCenterCoordinates(currentBlock[0], currentBlock[1]);
					if (dest) {
						this.setPosition(dest[0], dest[1]);
						this.teleportLocked = true;
					}
				}
			} else {
				// unlock when we leave PORT tiles
				this.teleportLocked = false;
			}
		}
		return hasMoved;
	};

	this.stepMouth = function () {
		if ((0 < this.mouthRadiusIncrement && this.mouthRadius < this.minMouthRadius) || (this.mouthRadiusIncrement < 0 && this.maxMouthRadius < this.mouthRadius)) {
			this.mouthRadius += this.mouthRadiusIncrement;
		}
		if (this.mouthRadius === this.maxMouthRadius || this.mouthRadius === this.minMouthRadius) {
			this.mouthRadiusIncrement = -this.mouthRadiusIncrement;
		}
	};

	this.goLeft = function () {
		if (this.active) {
			this.nextDir = LEFT;
		}
	};

	this.goUp = function () {
		if (this.active) {
			this.nextDir = UP;
		}
	};

	this.goRight = function () {
		if (this.active) {
			this.nextDir = RIGHT;
		}
	};

	this.goDown = function () {
		if (this.active) {
			this.nextDir = DOWN;
		}
	};
};

var Ghost = function (ghostType) {
	var spawnCoordinate = getRandomCoordinateToSpawnGhost();

	if (!spawnCoordinate) {
		return; // NOTE: the map needs to have a cage to spawn a ghost
	}

	this.x = spawnCoordinate[0];
	this.y = spawnCoordinate[1];

	// TODO: implement ghost specific behavior
	// if (ghostType === RED) {
	//     this.x = ;
	//     this.y = ;
	// }

	this.prevDir = NO_DIRECTION;
	this.type = GHOST;
	this.ghostType = ghostType;
	this.frightened = false;
	this.frightenedTimeInSeconds = 0;
	this.timeToBeFrightenedInSeconds = 10;
	this.color = randomGoldenRatioColor();
	this.blackEyeOffsetX = 0;
	this.blackEyeOffsetY = 0;
	this.trangleOffsetX = 0;

	// cage release control
	this.spawnTimeInSeconds = timeSeconds();
	// stagger by ghost type plus small random jitter so exits are distinct
	this.releaseDelayInSeconds = ghostExitDelay[this.ghostType] + randomDouble(0.75, 1.75);
	this.released = false;
	this.exiting = false;
	this.hasExitedCage = false;
	this.doorBlock = getDoorBlockIndex();

	// periodic random direction changes
	this.lastDirectionChangeTimeInSeconds = timeSeconds();
	this.directionChangeIntervalInSeconds = randomDouble(1.5, 3.5);

	this.run = function () {
		if (this.active && !levelWon && !gameOver) {
			if (this.frightened) {
				if (this.timeToBeFrightenedInSeconds < diff(this.frightenedTimeInSeconds, timeSeconds())) {
					this.frightened = false;
					this.frightenedTimeInSeconds = 0;
				}
			}

			// trigger release after random delay
			if (!this.released && this.releaseDelayInSeconds <= diff(this.spawnTimeInSeconds, timeSeconds())) {
				this.released = true;
				this.exiting = true;
			}

			// while exiting, bias movement toward the door and then up through it
			if (this.exiting) {
				this.exitCageTowardDoor();
			} else if (this.dir === NO_DIRECTION) {
				this.chooseRandomDirection();
			}

			// periodic random direction change when centered on a tile
			if (!this.exiting) {
				this.randomDirectionChangeTick();
			}

			this.move();

			// once we've made it to the path outside, stop exiting behavior
			if (this.exiting) {
				var currentBlock = getBlockFromGameObject(this);
				var currentMaze = mazes[currentMazeLevel];
				if (currentMaze[currentBlock[0]] && (currentMaze[currentBlock[0]][currentBlock[1]] === PASS || currentMaze[currentBlock[0]][currentBlock[1]] === PATH)) {
					this.exiting = false;
					this.hasExitedCage = true;
				}
			}

			this.setBlackEyeOffset();
		}
	};

	this.draw = function () {
		if (!levelWon && !gameOver) {
			var bodyOffsetY = this.radius * 2 / 5;
			var eyeOffsetX = this.radius / 2;

			// ghost body
			if (this.frightened) {
				fill(colors.aquamarine);
			} else {
				fill(this.color);
			}
			circle(this.x, this.y - bodyOffsetY, this.radius);
			rect(this.x - this.radius, this.y - bodyOffsetY, this.radius * 2, this.radius + bodyOffsetY / 10);

			// ghost eyes
			fill(colors.white);
			circle(this.x - eyeOffsetX, this.y - bodyOffsetY, this.radius / 3); // left white eye
			circle(this.x + eyeOffsetX, this.y - bodyOffsetY, this.radius / 3); // right white eye
			fill(colors.black);
			circle(this.x - eyeOffsetX + this.blackEyeOffsetX, this.y - bodyOffsetY + this.blackEyeOffsetY, this.radius / 8); // left black eye
			circle(this.x + eyeOffsetX + this.blackEyeOffsetX, this.y - bodyOffsetY + this.blackEyeOffsetY, this.radius / 8); // right black eye

			// ghost feet
			if (this.frightened) {
				fill(colors.aquamarine);
			} else {
				fill(this.color);
			}
			var numTriangles = 3;
			var triangleWidth = (this.radius * 2) / numTriangles;
			for (var i = 0; i < numTriangles; i++) {
				var triangleXPos = this.x - this.radius + this.trangleOffsetX + triangleWidth * i;
				var triangleYPos = this.y - bodyOffsetY + this.radius;
				triangle( // look into using quadratic curves
					triangleXPos, triangleYPos,
					triangleXPos + triangleWidth, triangleYPos,
					triangleXPos + triangleWidth / 2, triangleYPos + bodyOffsetY
				);
			}
		}
	};

	this.chooseRandomDirection = function () {
		var possibleDirections = [LEFT, UP, RIGHT, DOWN];
		var nearBlockTypes = this.getNearBlockTypes();
		var currentBlockCoords = getBlockFromGameObject(this);
		var currentMaze = mazes[currentMazeLevel];
		var currentTileType = currentMaze[currentBlockCoords[0]] && currentMaze[currentBlockCoords[0]][currentBlockCoords[1]];
		//  NOTE: getNearBlockTypes() returns an array of block types in the order of LEFT, UP, RIGHT, DOWN -> 0, 1, 2, 3
		//  so we can use the index to get the block type for the direction
		var directionLookup = { '-1': 0, '-2': 1, '1': 2, '2': 3 };

		var isOpposite = function (a, b) { return a + b === 0; };

		// filter out blocked directions up front
		possibleDirections = possibleDirections.filter(function (dir) {
			var idx = directionLookup[dir];
			var targetType = nearBlockTypes[idx];
			if (targetType === WALL || targetType === PORT) return false;
			if (targetType === DOOR && (!this.released || this.hasExitedCage)) return false;
			if (targetType === CAGE && (this.hasExitedCage || currentTileType !== CAGE)) return false;
			return true;
		}.bind(this));

		// avoid immediate reversal when possible
		var nonReverse = possibleDirections.filter(function (d) { return !isOpposite(d, this.prevDir); }.bind(this));
		var candidates = nonReverse.length ? nonReverse : possibleDirections;

		var newDirection = candidates.length ? randomElement(candidates) : this.prevDir;
		if (!newDirection) {
			newDirection = NO_DIRECTION;
		}
		this.dir = newDirection;
		this.prevDir = newDirection;
	};

	this.exitCageTowardDoor = function () {
		var currentBlock = getBlockFromGameObject(this);
		var currentCol = currentBlock[1];
		var doorCol = this.doorBlock[1];
		if (currentCol < doorCol) {
			this.dir = RIGHT;
		} else if (doorCol < currentCol) {
			this.dir = LEFT;
		} else {
			// aligned with door column; move up through the door
			this.dir = UP;
		}
		this.prevDir = this.dir;
	};

	this.isAtBlockCenter = function () {
		var center = getCenterCoordinatesFromBlockIndex.apply(null, getBlockFromGameObject(this));
		return (abs(this.x - center[0]) <= this.speed) && (abs(this.y - center[1]) <= this.speed);
	};

	this.randomDirectionChangeTick = function () {
		if (this.isAtBlockCenter()) {
			if (this.directionChangeIntervalInSeconds <= diff(this.lastDirectionChangeTimeInSeconds, timeSeconds())) {
				this.chooseRandomDirection();
				this.lastDirectionChangeTimeInSeconds = timeSeconds();
				this.directionChangeIntervalInSeconds = randomDouble(1.5, 3.5);
			}
		}
	};

	this.move = function () {
		if (this.active) {
			// var nearGameObjects = this.getNearGameObjectsOfType(GHOST);
			var nearBlockTypes = this.getNearBlockTypes();
			var currentBlockCoords = getBlockFromGameObject(this);
			var currentMaze = mazes[currentMazeLevel];
			var currentTileType = currentMaze[currentBlockCoords[0]] && currentMaze[currentBlockCoords[0]][currentBlockCoords[1]];
			var directionLookup = {
				'-1': 0, // LEFT
				'-2': 1, // UP
				'1': 2, // RIGHT
				'2': 3 // DOWN
			};
			var currentDirectionIndex = directionLookup[this.dir];
			if (-1 < currentDirectionIndex) {
			if (
					nearBlockTypes[currentDirectionIndex] === WALL ||
					// treat door as closed until released; and always closed once exited
					(nearBlockTypes[currentDirectionIndex] === DOOR && (!this.released || this.hasExitedCage)) ||
					// never allow moving from outside into cage; inside the cage during exit is allowed
				(nearBlockTypes[currentDirectionIndex] === CAGE && (this.hasExitedCage || currentTileType !== CAGE)) ||
				// ghosts cannot traverse ports; reverse
				(nearBlockTypes[currentDirectionIndex] === PORT)
				) {
				// reverse direction at ports or obstacles
				if (nearBlockTypes[currentDirectionIndex] === PORT && this.prevDir && this.prevDir !== NO_DIRECTION) {
					this.reverseDir();
				} else {
					this.dir = NO_DIRECTION;
				}
					this.moveToCenterOfCurrentBlock();
					return;
				}
			} else {
				return;
			}
			var centerCoordinates = getCenterCoordinatesFromBlockIndex.apply(null, getBlockFromGameObject(this));
			if (abs(this.dir) === 1) {
				this.x += this.speed * this.dir;
				this.y = centerCoordinates[1];
			} else {
				if (0 < this.dir) {
					this.y += this.speed;
				} else {
					this.y -= this.speed;
				}
				this.x = centerCoordinates[0];
			}
		}
	};

	this.setBlackEyeOffset = function () {
		switch (this.dir) {
			case LEFT:
				this.blackEyeOffsetX = -this.radius / 10;
				this.blackEyeOffsetY = -this.radius / 12;
				break;
			case UP:
				this.blackEyeOffsetX = 0;
				this.blackEyeOffsetY = -this.radius / 8;
				break;
			case RIGHT:
				this.blackEyeOffsetX = this.radius / 10;
				this.blackEyeOffsetY = this.radius / 12;
				break;
			case DOWN:
				this.blackEyeOffsetX = 0;
				this.blackEyeOffsetY = this.radius / 8;
				break;
			default:
				this.blackEyeOffsetX = 0;
				this.blackEyeOffsetY = 0;
		}
	};

	this.frighten = function () {
		this.frightened = true;
		this.frightenedTimeInSeconds = timeSeconds();
	};

	this.isFrightened = function () {
		return this.frightened;
	};
};

var GameBackground = function () {
	this.collidable = false;

	this.draw = function () {
		background(colors.black);
	};
};

var GameLevel = function () {
	var voidColor = randomGoldenRatioColor();
	var wallColor = randomGoldenRatioColor();
	var pathColor = randomGoldenRatioColor();
	var cageColor = randomGoldenRatioColor();
	var doorColor = randomGoldenRatioColor();

	this.draw = function () {
		noStroke();
		var currentMaze = mazes[currentMazeLevel];
		currentMaze.forEach(function (levelRow, rowIndex) {
			levelRow.forEach(function (rowBlock, columnIndex) {
				if (currentMaze[rowIndex][columnIndex] === VOID) {
					fill(voidColor);
				} else if (currentMaze[rowIndex][columnIndex] === WALL) {
					fill(wallColor);
				} else if ([PATH, PASS, PORT].includes(currentMaze[rowIndex][columnIndex])) {
					fill(pathColor);
				} else if (currentMaze[rowIndex][columnIndex] === CAGE) {
					fill(cageColor);
				} else if (currentMaze[rowIndex][columnIndex] === DOOR) {
					fill(doorColor);
				}
				var blockCoordinates = getCoordinatesFromBlockIndex(rowIndex, columnIndex);
				rect(blockCoordinates[0], blockCoordinates[1], blockWidth + 1, blockHeight + 1);
			});
		});
	};
};

var PausedScreen = function () {
	this.collidable = false;

	this.draw = function () {
		if (isPaused) {
			alpha(0.5);
			background(colors.yellow);
			alpha(1.0);
			textSize(100);
			fill(colors.black);
			text('PAUSED', 100, maxHeight / 2);
		}
	};
};

var GameOverScreen = function () {
	this.collidable = false;

	this.draw = function () {
		if (gameOver) {
			alpha(0.5);
			background(colors.red);
			alpha(1.0);
			textSize(100);
			fill(colors.black);
			// TODO: fix text for mobile devices
			text('GAME OVER', 100, maxHeight / 2);
		}
	};
};

var WonScreen = function () {
	this.collidable = false;

	this.draw = function () {
		if (levelWon) {
			alpha(0.5);
			background(colors.green);
			alpha(1.0);
			textSize(100);
			fill(colors.black);
			// TODO: fix text for mobile devices
			text('LEVEL WON!!', 100, maxHeight / 2);
		}
	};
};

var Food = function () {
	this.type = FOOD;
	this.collidable = false;

	this.draw = function () {
		fill(colors.white);
		arc(this.x, this.y, this.radius, 0, TWO_PI, true);
	};

	this.getRadius = function () {
		return this.radius;
	};

	this.setRadius = function (newRadius) {
		this.radius = newRadius;
	};
};

var Pill = function () {
	this.type = PILL;
	this.collidable = false;

	this.draw = function () {
		fill(colors.white);
		arc(this.x, this.y, this.radius, 0, TWO_PI, true);
	};

	this.getRadius = function () {
		return this.radius;
	};

	this.setRadius = function (newRadius) {
		this.radius = newRadius;
	};
};

var Scene = function () {
	this.init = function () {
		this.configurePrototypes();

		// reset transient state between levels/restarts
		pendingGhostRespawns = [];
		eatenGhosts = 0;

		gameObjects = [];
		gameObjects.push(new GameBackground());
		gameObjects.push(new GameLevel());

		this.generateFood();
		this.generatePills();
		this.generatePacman();
		this.generateGhosts(numGhosts);

		gameObjects.push(new PausedScreen());
		gameObjects.push(new GameOverScreen());
		gameObjects.push(new WonScreen());
	};

	this.configurePrototypes = function () {
		var minBlockDimension = min(blockHeight, blockWidth);
		MovableGameObject.prototype = new GameObject();
		Pacman.prototype = new MovableGameObject();
		Ghost.prototype = new MovableGameObject();
		Ghost.prototype.speed = (minBlockDimension * 0.6) / 20;
		Ghost.prototype.radius = (minBlockDimension * 0.6) / 2;
		GameBackground.prototype = new GameObject();
		GameLevel.prototype = new GameObject();
		PausedScreen.prototype = new GameObject();
		GameOverScreen.prototype = new GameObject();
		WonScreen.prototype = new GameObject();
		Food.prototype = new GameObject();
		Food.prototype.radius = minBlockDimension * 0.1;
		Pill.prototype = new GameObject();
		Pill.prototype.radius = minBlockDimension * 0.2;
	};

	this.generateFood = function () {
		if (food[currentMazeLevel].length === 0) {
			food[currentMazeLevel] = getCoordinatesOfType(PATH);
		}
		var currentFood = food[currentMazeLevel];
		currentFood.forEach(function (food) {
			var foodObject = new Food();
			foodObject.setPosition.apply(foodObject, getCenterCoordinatesFromBlockIndex.apply(null, food));
			gameObjects.push(foodObject);
		});
	};

	this.generatePills = function () {
		var currentPill = pills[currentMazeLevel];
		currentPill.forEach(function (pill) {
			var pillObject = new Pill();
			pillObject.setPosition.apply(pillObject, getCenterCoordinatesFromBlockIndex.apply(null, pill));
			gameObjects.push(pillObject);
		});
	};

	this.generatePacman = function () {
		pacman = new Pacman();
		pacman.init.apply(pacman, getRealCoordinateToSpawnPacman());
		gameObjects.push(pacman);
	};

	this.generateGhosts = function (num) {
		for (var i = 0; i < num; i++) {
			gameObjects.push(new Ghost(ghostRankings[i % 4]));
		}
	};

	this.monitorCollisions = function () {
		var i = 0, l = 0;

		var ghosts = getGameObjectsOfType(GHOST);
		for (i = 0, l = ghosts.length; i < l; i++) {
			if (collideBlock(pacman, ghosts[i])) {
				if (ghosts[i].isFrightened()) {
					ghosts[i].kill();
					eatenGhosts++;
					scheduleGhostRespawn(ghosts[i].ghostType, 3);
				} else {
					this.gameOver();
				}
				break;
			}
		}

		var food = getGameObjectsOfType(FOOD);
		for (i = 0, l = food.length; i < l; i++) {
			if (collidePoint(pacman, food[i])) {
				food[i].kill();
				break;
			}
		}

		var pills = getGameObjectsOfType(PILL);
		for (i = 0, l = pills.length; i < l; i++) {
			if (collidePoint(pacman, pills[i])) {
				pills[i].kill();
				frightenGhosts();
				break;
			}
		}
	};

	this.gameOver = function () {
		gameOver = true;
	};

	this.retry = function () {
		if (gameOver) {
			this.init();
		}
	};
};

var setup = function () {
	if (doFullScreen) {
		fullScreenCanvas();
	} else {
		size(mapSize.width, mapSize.height);
	}
	getBlockDimensions();
	mainScene = new Scene();
	mainScene.init();
};

var draw = function () {
	if (!levelWon) {
		checkFood();
	}
	checkGameObjects();
	processGhostRespawns();
	monitorKeys();
	gameObjects.forEach(function (obj) {
		obj.active && obj.run && obj.run();
		obj.draw && obj.draw();
	});
	if (!gameOver) {
		mainScene.monitorCollisions();
	}
};

function monitorKeys() {
	if (keyCodeList[keys.SPACE] === true) {
		// maybe interact with pause screen?
		// how to interact with pause screen on touch screens?
	}
	if (keyCodeList[keys.LEFT] === true || keyCodeList[keys.A] === true) {
		pacman.goLeft();
	}
	if (keyCodeList[keys.UP] === true || keyCodeList[keys.W] === true) {
		pacman.goUp();
	}
	if (keyCodeList[keys.RIGHT] === true || keyCodeList[keys.D] === true) {
		pacman.goRight();
	}
	if (keyCodeList[keys.DOWN] === true || keyCodeList[keys.S] === true) {
		pacman.goDown();
	}
}

mouseClicked = function () {
	if (isPaused) {
		playPause();
	}
	if (gameOver) {
		currentMazeLevel = 0;
		getBlockDimensions();
		mainScene.init();
		gameOver = false;
		levelWon = false;
	}
	if (levelWon) {
		if (currentMazeLevel < mazes.length - 1) {
			currentMazeLevel++;
		} else {
			currentMazeLevel = 0;
		}
		if (food[currentMazeLevel].length === 0) {
			food[currentMazeLevel] = getCoordinatesOfType(PATH);
		}
		getBlockDimensions();
		mainScene.init();
		levelWon = false;
	}
};

touchMoved = function () { // should the swipe direction be passed in as an argument from canvasengine?
	fill(colors.white);
	for (var i = 0; i < touchesList.length; i++) { // should i add the ability to show touches in canvasengine?
		arc(touchesList[i].pageX, touchesList[i].pageY, 10, 0, TWO_PI, true);
	}
};

touchStart = function () {
	if (touchesList.length === 1) {
		initialTouchX = touchesList[0].pageX;
		initialTouchY = touchesList[0].pageY;
	} else {
		initialTouchX = 0;
		initialTouchY = 0;
	}
};

touchEnd = function (e) {
	if (0 < initialTouchX && 0 < initialTouchY) {
		finalTouchX = e.changedTouches[0].pageX;
		finalTouchY = e.changedTouches[0].pageY;
		calculateSwipeDirection();
	}
};

function calculateSwipeDirection() {
	var swipeDirection;
	if (initialTouchX > finalTouchX) {
		swipeDirection = LEFT;
		if (abs(initialTouchX - finalTouchX) < abs(initialTouchY - finalTouchY)) {
			if (initialTouchY > finalTouchY) {
				swipeDirection = UP;
			} else if (initialTouchY < finalTouchY) {
				swipeDirection = DOWN;
			}
		}
	} else if (initialTouchX < finalTouchX) {
		swipeDirection = RIGHT;
		if (abs(initialTouchX - finalTouchX) < abs(initialTouchY - finalTouchY)) {
			if (initialTouchY > finalTouchY) {
				swipeDirection = UP;
			} else if (initialTouchY < finalTouchY) {
				swipeDirection = DOWN;
			}
		}
	} else {
		if (initialTouchY > finalTouchY) {
			swipeDirection = UP;
		} else if (initialTouchY < finalTouchY) {
			swipeDirection = DOWN;
		}
	}
	if (swipeDirection) {
		pacman.nextDir = swipeDirection;
	}
}

keyDown = function () {
	if (keyCodeList[keys.P] === true) {
		// how to pause on mobile device touch screens?
		playPause();
	}
};

orientationChanged = function () {
	mapSize = {
		height: (doFullScreen) ? maxHeight : 500,
		width: (doFullScreen) ? maxWidth : 800
	};
	getBlockDimensions();
	mainScene.init();
};

windowResized = function () {
	orientationChanged();
};

function playPause() {
	if (isPaused) {
		gameObjects.forEach(function (obj) {
			obj.activate && obj.activate();
		});
	} else {
		gameObjects.forEach(function (obj) {
			obj.deactivate && obj.deactivate();
		});
	}
	isPaused = !isPaused;
}

function checkFood() {
	var food = getGameObjectsOfType(FOOD);
	var pills = getGameObjectsOfType(PILL);
	if (!food.length && !pills.length) {
		levelWon = true;
	}
}

function frightenGhosts() {
	var ghosts = getGameObjectsOfType(GHOST);
	ghosts.forEach(function (ghost) {
		ghost.frighten();
	});
}

function checkGameObjects() {
	var badObjects = [];
	gameObjects.forEach(function (obj) {
		if (obj.destroy) {
			badObjects.push(obj);
		}
	});
	badObjects.forEach(function (obj) {
		gameObjects.splice(gameObjects.indexOf(obj), 1);
	});
}

window.onload = function () {
	window.canvas = new Canvas(document.getElementById('canvas1'));
	window.ctx = canvas.ctx;
	canvas.setup = window.setup;
	canvas.draw = window.draw;
	canvas.run();
};
</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-42786295-1"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-42786295-1');
</script>
</body>
</html>
