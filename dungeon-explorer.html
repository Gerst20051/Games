<!--
 ::::::::  :::::::::  ::::::::::     ::: ::::::::::: :::::::::: :::::::::       :::::::::  :::   :::                               
:+:    :+: :+:    :+: :+:          :+: :+:   :+:     :+:        :+:    :+:      :+:    :+: :+:   :+: :+:                           
+:+        +:+    +:+ +:+         +:+   +:+  +:+     +:+        +:+    +:+      +:+    +:+  +:+ +:+                                
+#+        +#++:++#:  +#++:++#   +#++:++#++: +#+     +#++:++#   +#+    +:+      +#++:++#+    +#++:                                 
+#+        +#+    +#+ +#+        +#+     +#+ +#+     +#+        +#+    +#+      +#+    +#+    +#+                                  
#+#    #+# #+#    #+# #+#        #+#     #+# #+#     #+#        #+#    #+#      #+#    #+#    #+#    #+#                           
 ########  ###    ### ########## ###     ### ###     ########## #########       #########     ###                                  
                                                                                                                                   
                                                                                                                                   
                                                                                                                                   
    :::     ::::    ::: :::::::::  :::::::::  :::::::::: :::       :::       ::::::::  :::::::::: :::::::::   :::::::: ::::::::::: 
  :+: :+:   :+:+:   :+: :+:    :+: :+:    :+: :+:        :+:       :+:      :+:    :+: :+:        :+:    :+: :+:    :+:    :+:     
 +:+   +:+  :+:+:+  +:+ +:+    +:+ +:+    +:+ +:+        +:+       +:+      +:+        +:+        +:+    +:+ +:+           +:+     
+#++:++#++: +#+ +:+ +#+ +#+    +:+ +#++:++#:  +#++:++#   +#+  +:+  +#+      :#:        +#++:++#   +#++:++#:  +#++:++#++    +#+     
+#+     +#+ +#+  +#+#+# +#+    +#+ +#+    +#+ +#+        +#+ +#+#+ +#+      +#+   +#+# +#+        +#+    +#+        +#+    +#+     
#+#     #+# #+#   #+#+# #+#    #+# #+#    #+# #+#         #+#+# #+#+#       #+#    #+# #+#        #+#    #+# #+#    #+#    #+#     
###     ### ###    #### #########  ###    ### ##########   ###   ###         ########  ########## ###    ###  ########     ###     
-->
<!DOCTYPE html><html><head><meta charset="utf-8">
<title>Dungeon Explorer (via Canvas Engine)</title>
<script src="canvasengine.js"></script>
<style>
body {
    margin: 0;
    padding: 0;
}

#canvaspane {
    cursor: default;
}
</style>
</head>
<body>
<div id="content">
<div id="canvaspane">
<canvas id="canvas1" width="100" height="100"></canvas>
</div>
</div>
<script>
let TILE_SIZE = 20;
let MAP_WIDTH = 40;  // Viewport size
let MAP_HEIGHT = 30; // Viewport size
let WORLD_WIDTH = 80;  // Actual world size (double viewport)
let WORLD_HEIGHT = 60; // Actual world size (double viewport)

const TILE = {
    DOOR: 0,
    FLOOR: 1,
    WALL: 2,
};

class Player {
    constructor(x = 0, y = 0) {
        this.x = x;
        this.y = y;
        this.health = 100;
        this.maxHealth = 100;
        this.level = 1;
        this.exp = 0;
    }

    move(newX, newY) {
        this.x = newX;
        this.y = newY;
    }

    takeDamage(damage) {
        this.health -= damage;
        return this.health <= 0;
    }

    heal(amount) {
        this.health = Math.min(this.maxHealth, this.health + amount);
    }

    gainExp(amount) {
        this.exp += amount;
        if (this.exp >= this.level * 100) {
            this.level++;
            this.maxHealth += 10;
            this.health = this.maxHealth;
            return true;
        }
        return false;
    }
}

class Enemy {
    constructor(x, y, type = 'goblin') {
        this.x = x;
        this.y = y;
        this.type = type;
        this.health = type === 'goblin' ? 20 + Math.floor(Math.random() * 20) : 30 + Math.floor(Math.random() * 20);
        this.maxHealth = 40;
        this.damage = 5 + Math.floor(Math.random() * 5);
    }

    moveTowards(targetX, targetY, world) {
        const dx = targetX - this.x;
        const dy = targetY - this.y;

        let newX = this.x;
        let newY = this.y;

        if (Math.abs(dx) > Math.abs(dy)) {
            newX += dx > 0 ? 1 : -1;
        } else {
            newY += dy > 0 ? 1 : -1;
        }

        if (world.isValidMove(newX, newY)) {
            this.x = newX;
            this.y = newY;
        }
    }

    takeDamage(damage) {
        this.health -= damage;
        return this.health <= 0;
    }
}

class Item {
    constructor(x, y, type = 'health_potion') {
        this.x = x;
        this.y = y;
        this.type = type;

        switch (type) {
            case 'health_potion':
                this.name = 'Health Potion';
                this.healing = 25;
                break;
            case 'gold':
                this.name = 'Gold';
                this.value = Math.floor(Math.random() * 50) + 10;
                break;
            case 'weapon':
                this.name = 'Magic Sword';
                this.damage = Math.floor(Math.random() * 10) + 5;
                break;
        }
    }

    use(player) {
        switch (this.type) {
            case 'health_potion':
                player.heal(this.healing);
                break;
            case 'gold':
                return player.gainExp(this.value);
            case 'weapon':
                return player.gainExp(this.damage);
        }
        return false;
    }
}

class Camera {
    constructor() {
        this.x = 0;
        this.y = 0;
    }

    follow(target) {
        this.x = target.x;
        this.y = target.y;
    }

    worldToScreen(worldX, worldY) {
        const screenCenterX = Math.floor(MAP_WIDTH / 2);
        const screenCenterY = Math.floor(MAP_HEIGHT / 2);

        return {
            x: worldX - this.x + screenCenterX,
            y: worldY - this.y + screenCenterY,
        };
    }

    isVisible(worldX, worldY) {
        const screen = this.worldToScreen(worldX, worldY);
        return screen.x >= -1 && screen.x <= MAP_WIDTH && screen.y >= -1 && screen.y <= MAP_HEIGHT;
    }
}

class World {
    constructor(width, height) {
        this.width = width;
        this.height = height;
        this.map = [];
        this.rooms = [];
    }

    generate() {
        // Initialize world map with walls
        this.map = [];
        for (let y = 0; y < this.height; y++) {
            this.map[y] = [];
            for (let x = 0; x < this.width; x++) {
                this.map[y][x] = TILE.WALL;
            }
        }

        this.rooms = [];

        // Generate rooms
        const roomCount = Math.floor(Math.random() * 9) + 16;

        for (let i = 0; i < roomCount; i++) {
            const room = this.generateRoom();
            if (room && !this.roomOverlaps(room)) {
                this.rooms.push(room);
                this.carveRoom(room);
            }
        }

        // Connect rooms with corridors
        this.connectRooms();
    }

    generateRoom() {
        let attempts = 0;
        while (attempts < 100) {
            const width = Math.floor(Math.random() * 8) + 4;
            const height = Math.floor(Math.random() * 6) + 4;
            const x = Math.floor(Math.random() * (this.width - width - 2)) + 1;
            const y = Math.floor(Math.random() * (this.height - height - 2)) + 1;
            const room = { x, y, width, height };
            if (!this.roomOverlaps(room)) {
                return room;
            }
            attempts++;
        }
        return null;
    }

    roomOverlaps(newRoom) {
        for (let i = 0; i < this.rooms.length; i++) {
            const room = this.rooms[i];
            if (newRoom.x < room.x + room.width + 1 &&
                newRoom.x + newRoom.width + 1 > room.x &&
                newRoom.y < room.y + room.height + 1 &&
                newRoom.y + newRoom.height + 1 > room.y) {
                return true;
            }
        }
        return false;
    }

    carveRoom(room) {
        for (let y = room.y; y < room.y + room.height; y++) {
            for (let x = room.x; x < room.x + room.width; x++) {
                this.map[y][x] = TILE.FLOOR;
            }
        }
    }

    connectRooms() {
        for (let i = 1; i < this.rooms.length; i++) {
            const prevRoom = this.rooms[i - 1];
            const currRoom = this.rooms[i];
            const prevCenter = {
                x: Math.floor(prevRoom.x + prevRoom.width / 2),
                y: Math.floor(prevRoom.y + prevRoom.height / 2),
            };
            const currCenter = {
                x: Math.floor(currRoom.x + currRoom.width / 2),
                y: Math.floor(currRoom.y + currRoom.height / 2),
            };
            if (Math.random() < 0.5) {
                this.createHorizontalTunnel(prevCenter.x, currCenter.x, prevCenter.y);
                this.createVerticalTunnel(prevCenter.y, currCenter.y, currCenter.x);
            } else {
                this.createVerticalTunnel(prevCenter.y, currCenter.y, prevCenter.x);
                this.createHorizontalTunnel(prevCenter.x, currCenter.x, currCenter.y);
            }
        }
    }

    createHorizontalTunnel(x1, x2, y) {
        const minX = Math.min(x1, x2);
        const maxX = Math.max(x1, x2);
        for (let x = minX; x <= maxX; x++) {
            if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
                this.map[y][x] = TILE.FLOOR;
            }
        }
    }

    createVerticalTunnel(y1, y2, x) {
        const minY = Math.min(y1, y2);
        const maxY = Math.max(y1, y2);
        for (let y = minY; y <= maxY; y++) {
            if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
                this.map[y][x] = TILE.FLOOR;
            }
        }
    }

    isValidMove(x, y) {
        return x >= 0 && x < this.width && y >= 0 && y < this.height && this.map[y][x] !== TILE.WALL;
    }

    getTileAt(x, y) {
        if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
            return this.map[y][x];
        }
        return TILE.WALL;
    }

    getRoomAt(x, y) {
        for (let i = 0; i < this.rooms.length; i++) {
            const room = this.rooms[i];
            if (x >= room.x && x < room.x + room.width && y >= room.y && y < room.y + room.height) {
                return i;
            }
        }
        return null;
    }
}

class Game {
    constructor() {
        this.world = new World(WORLD_WIDTH, WORLD_HEIGHT);
        this.player = new Player();
        this.camera = new Camera();
        this.enemies = [];
        this.items = [];
        this.currentLevel = 1;
        this.turnCount = 0;
        this.gameRunning = true;
    }

    init() {
        this.generateDungeon();
    }

    generateDungeon() {
        this.world.generate();
        if (this.world.rooms.length > 0) {
            const centerRoom = this.findCenterMostRoom();
            this.player.x = Math.floor(centerRoom.x + centerRoom.width / 2);
            this.player.y = Math.floor(centerRoom.y + centerRoom.height / 2);
            this.camera.follow(this.player);
        }
        this.generateEnemies();
        this.generateItems();
    }

    findCenterMostRoom() {
        const worldCenterX = WORLD_WIDTH / 2;
        const worldCenterY = WORLD_HEIGHT / 2;

        let closestRoom = this.world.rooms[0];
        let minDistance = Infinity;

        for (let i = 0; i < this.world.rooms.length; i++) {
            const room = this.world.rooms[i];
            const roomCenterX = room.x + room.width / 2;
            const roomCenterY = room.y + room.height / 2;
            const distance = Math.sqrt(Math.pow(roomCenterX - worldCenterX, 2) +  Math.pow(roomCenterY - worldCenterY, 2));
            if (distance < minDistance) {
                minDistance = distance;
                closestRoom = room;
            }
        }

        return closestRoom;
    }

    generateEnemies() {
        this.enemies = [];
        const enemyCount = Math.floor(Math.random() * 16) + 10;

        for (let i = 0; i < enemyCount; i++) {
            const room = this.world.rooms[Math.floor(Math.random() * this.world.rooms.length)];
            const x = room.x + Math.floor(Math.random() * room.width);
            const y = room.y + Math.floor(Math.random() * room.height);

            if (x !== this.player.x || y !== this.player.y) {
                const type = Math.random() < 0.7 ? 'goblin' : 'orc';
                this.enemies.push(new Enemy(x, y, type));
            }
        }
    }

    generateItems() {
        this.items = [];
        const itemCount = Math.floor(Math.random() * 12) + 6;

        for (let i = 0; i < itemCount; i++) {
            const room = this.world.rooms[Math.floor(Math.random() * this.world.rooms.length)];
            const x = room.x + Math.floor(Math.random() * room.width);
            const y = room.y + Math.floor(Math.random() * room.height);

            const itemType = Math.random();
            let type;
            if (itemType < 0.4) {
                type = 'health_potion';
            } else if (itemType < 0.7) {
                type = 'gold';
            } else {
                type = 'weapon';
            }

            this.items.push(new Item(x, y, type));
        }
    }

    handleKeyDown() {
        if (!this.gameRunning) return;

        let newX = this.player.x;
        let newY = this.player.y;
        let moved = false;

        switch (keyCode) {
            case keys.UP:
            case keys.W:
                newY--;
                moved = true;
                break;
            case keys.DOWN:
            case keys.S:
                newY++;
                moved = true;
                break;
            case keys.LEFT:
            case keys.A:
                newX--;
                moved = true;
                break;
            case keys.RIGHT:
            case keys.D:
                newX++;
                moved = true;
                break;
            case keys.R:
                this.generateDungeon();
                return;
        }

        if (moved && this.world.isValidMove(newX, newY)) {
            this.player.move(newX, newY);
            this.camera.follow(this.player);

            this.checkForItems();
            this.checkForCombat();

            if (this.gameRunning) {
                this.enemyTurn();
            }

            this.turnCount++;
        }
    }

    checkForItems() {
        for (let i = this.items.length - 1; i >= 0; i--) {
            const item = this.items[i];
            if (item.x === this.player.x && item.y === this.player.y) {
                item.use(this.player);
                this.items.splice(i, 1);
            }
        }
    }

    checkForCombat() {
        for (let i = 0; i < this.enemies.length; i++) {
            const enemy = this.enemies[i];
            if (enemy.x === this.player.x && enemy.y === this.player.y) {
                const playerDamage = 10 + Math.floor(Math.random() * 10);
                if (enemy.takeDamage(playerDamage)) {
                    this.enemies.splice(i, 1);
                    this.player.gainExp(15);
                } else {
                    const enemyDamage = enemy.damage + Math.floor(Math.random() * 5);
                    if (this.player.takeDamage(enemyDamage)) {
                        this.gameRunning = false;
                    }
                }
                break;
            }
        }
    }

    enemyTurn() {
        for (let i = 0; i < this.enemies.length; i++) {
            const enemy = this.enemies[i];

            const playerRoom = this.world.getRoomAt(this.player.x, this.player.y);
            const enemyRoom = this.world.getRoomAt(enemy.x, enemy.y);

            if (playerRoom === enemyRoom && playerRoom !== null) {
                enemy.moveTowards(this.player.x, this.player.y, this.world);
            }
        }
    }

    draw() {
        background(0, 0, 0);

        // Calculate visible world bounds
        const viewCenterX = Math.floor(MAP_WIDTH / 2);
        const viewCenterY = Math.floor(MAP_HEIGHT / 2);
        const worldStartX = this.camera.x - viewCenterX - 1;
        const worldStartY = this.camera.y - viewCenterY - 1;
        const worldEndX = this.camera.x + viewCenterX + 1;
        const worldEndY = this.camera.y + viewCenterY + 1;

        // Draw map (only visible tiles)
        for (let worldY = Math.max(0, worldStartY); worldY < Math.min(this.world.map.length, worldEndY); worldY++) {
            for (let worldX = Math.max(0, worldStartX); worldX < Math.min(this.world.map[0].length, worldEndX); worldX++) {
                const screen = this.camera.worldToScreen(worldX, worldY);

                if (screen.x < -1 || screen.x >= MAP_WIDTH || screen.y < -1 || screen.y >= MAP_HEIGHT) continue;

                const tile = this.world.map[worldY][worldX];
                const screenX = screen.x * TILE_SIZE;
                const screenY = screen.y * TILE_SIZE;

                switch (tile) {
                    case TILE.WALL:
                        fill(100, 100, 100);
                        break;
                    case TILE.FLOOR:
                        fill(200, 180, 140);
                        break;
                    case TILE.DOOR:
                        fill(139, 69, 19);
                        break;
                }

                noStroke();
                rect(screenX, screenY, TILE_SIZE, TILE_SIZE);
            }
        }

        // Draw items (only visible ones)
        for (let i = 0; i < this.items.length; i++) {
            const item = this.items[i];

            if (!this.camera.isVisible(item.x, item.y)) continue;

            const screen = this.camera.worldToScreen(item.x, item.y);
            const screenX = screen.x * TILE_SIZE + TILE_SIZE / 2;
            const screenY = screen.y * TILE_SIZE + TILE_SIZE / 2;

            if (item.type === 'health_potion') {
                fill(255, 0, 0);
            } else if (item.type === 'gold') {
                fill(255, 215, 0);
            } else {
                fill(192, 192, 192);
            }

            noStroke();
            ellipse(screenX, screenY, TILE_SIZE / 2, TILE_SIZE / 2);
        }

        // Draw enemies (only visible ones)
        for (let i = 0; i < this.enemies.length; i++) {
            const enemy = this.enemies[i];

            if (!this.camera.isVisible(enemy.x, enemy.y)) continue;

            const screen = this.camera.worldToScreen(enemy.x, enemy.y);
            const screenX = screen.x * TILE_SIZE + TILE_SIZE / 2;
            const screenY = screen.y * TILE_SIZE + TILE_SIZE / 2;

            if (enemy.type === 'goblin') {
                fill(0, 150, 0);
            } else {
                fill(150, 0, 0);
            }

            noStroke();
            ellipse(screenX, screenY, TILE_SIZE / 2, TILE_SIZE / 2);
        }

        // Draw player (always at screen center)
        const playerCenterX = Math.floor(MAP_WIDTH / 2);
        const playerCenterY = Math.floor(MAP_HEIGHT / 2);
        const playerScreenX = playerCenterX * TILE_SIZE + TILE_SIZE / 2;
        const playerScreenY = playerCenterY * TILE_SIZE + TILE_SIZE / 2;
        fill(0, 0, 255);
        noStroke();
        ellipse(playerScreenX, playerScreenY, TILE_SIZE / 2, TILE_SIZE / 2);

        this.drawUI();
    }

    drawUI() {
        const uiStartY = MAP_HEIGHT * TILE_SIZE + 30;
        const fontSize = Math.max(12, Math.floor(TILE_SIZE * 0.6));
        textSize(fontSize);

        fill(255, 255, 255);
        text('Health: ' + this.player.health + '/' + this.player.maxHealth, 10, uiStartY);
        text('Level: ' + this.player.level, 150, uiStartY);
        text('Exp: ' + this.player.exp, 220, uiStartY);
        text('Turn: ' + this.turnCount, 320, uiStartY);
        text('Pos: ' + this.player.x + ',' + this.player.y, 400, uiStartY);

        if (!this.gameRunning) {
            fill(255, 0, 0);
            text('GAME OVER! Press R to restart', 10, uiStartY + fontSize + 10);
        } else {
            fill(200, 200, 200);
            text('Use WASD or arrow keys to move. R to regenerate dungeon.', 10, uiStartY + fontSize + 10);
        }
    }
}

function calculateMapDimensions() {
    // Reserve space for UI at the bottom
    const uiHeight = 80;
    const availableHeight = maxHeight - uiHeight;

    // Calculate how many tiles can fit with a reasonable minimum size
    const minTileSize = 12;
    const maxTileSize = 30;

    // Try to fit around 40 tiles width-wise, but adjust based on screen
    const desiredMapWidth = 40;
    let calculatedTileSize = Math.floor(maxWidth / desiredMapWidth);

    // Clamp tile size to reasonable bounds
    TILE_SIZE = Math.max(minTileSize, Math.min(maxTileSize, calculatedTileSize));

    // Calculate viewport dimensions based on the tile size
    MAP_WIDTH = Math.floor(maxWidth / TILE_SIZE);
    MAP_HEIGHT = Math.floor(availableHeight / TILE_SIZE);

    // Ensure minimum viewport size for playability
    MAP_WIDTH = Math.max(20, MAP_WIDTH);
    MAP_HEIGHT = Math.max(15, MAP_HEIGHT);

    // Create world that's double the viewport size in all directions
    WORLD_WIDTH = MAP_WIDTH * 2;
    WORLD_HEIGHT = MAP_HEIGHT * 2;

    console.log(`Screen: ${maxWidth}x${maxHeight}, Tiles: ${TILE_SIZE}px, Viewport: ${MAP_WIDTH}x${MAP_HEIGHT}, World: ${WORLD_WIDTH}x${WORLD_HEIGHT}`);
}

let game;

var setup = function(){
    fullScreenCanvas();
    calculateMapDimensions();

    game = new Game();
    game.init();
};

var draw = function(){
    if (game) {
        game.draw();
    }
};

var keyDown = function(){
    if (game) {
        game.handleKeyDown();
    }
};

var windowResized = debounce(function(){
    calculateMapDimensions();
    if (game) {
        game.generateDungeon();
    }
}, 500);

window.onload = function(){
    window.canvas = new Canvas(document.getElementById("canvas1"));
    window.ctx = canvas.ctx;
    canvas.setup = window.setup;
    canvas.draw = window.draw;
    canvas.run();
};
</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-42786295-1"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-42786295-1');
</script>
</body>
</html>
