<!--
 ::::::::  :::::::::  ::::::::::     ::: ::::::::::: :::::::::: :::::::::       :::::::::  :::   :::                               
:+:    :+: :+:    :+: :+:          :+: :+:   :+:     :+:        :+:    :+:      :+:    :+: :+:   :+: :+:                           
+:+        +:+    +:+ +:+         +:+   +:+  +:+     +:+        +:+    +:+      +:+    +:+  +:+ +:+                                
+#+        +#++:++#:  +#++:++#   +#++:++#++: +#+     +#++:++#   +#+    +:+      +#++:++#+    +#++:                                 
+#+        +#+    +#+ +#+        +#+     +#+ +#+     +#+        +#+    +#+      +#+    +#+    +#+                                  
#+#    #+# #+#    #+# #+#        #+#     #+# #+#     #+#        #+#    #+#      #+#    #+#    #+#    #+#                           
 ########  ###    ### ########## ###     ### ###     ########## #########       #########     ###                                  
                                                                                                                                   
                                                                                                                                   
                                                                                                                                   
    :::     ::::    ::: :::::::::  :::::::::  :::::::::: :::       :::       ::::::::  :::::::::: :::::::::   :::::::: ::::::::::: 
  :+: :+:   :+:+:   :+: :+:    :+: :+:    :+: :+:        :+:       :+:      :+:    :+: :+:        :+:    :+: :+:    :+:    :+:     
 +:+   +:+  :+:+:+  +:+ +:+    +:+ +:+    +:+ +:+        +:+       +:+      +:+        +:+        +:+    +:+ +:+           +:+     
+#++:++#++: +#+ +:+ +#+ +#+    +:+ +#++:++#:  +#++:++#   +#+  +:+  +#+      :#:        +#++:++#   +#++:++#:  +#++:++#++    +#+     
+#+     +#+ +#+  +#+#+# +#+    +#+ +#+    +#+ +#+        +#+ +#+#+ +#+      +#+   +#+# +#+        +#+    +#+        +#+    +#+     
#+#     #+# #+#   #+#+# #+#    #+# #+#    #+# #+#         #+#+# #+#+#       #+#    #+# #+#        #+#    #+# #+#    #+#    #+#     
###     ### ###    #### #########  ###    ### ##########   ###   ###         ########  ########## ###    ###  ########     ###     
-->
<!DOCTYPE html><html><head><meta charset="utf-8">
<title>Dungeon Explorer (via Canvas Engine)</title>
<script src="canvasengine.js"></script>
<style>
body {
	margin: 0;
	padding: 0;
}

#canvaspane {
	cursor: default;
}
</style>
</head>
<body>
<div id="content">
<div id="canvaspane">
<canvas id="canvas1" width="100" height="100"></canvas>
</div>
</div>
<script>
let TILE_SIZE = 20;
let MAP_WIDTH = 40;  // Viewport size
let MAP_HEIGHT = 30; // Viewport size
let WORLD_WIDTH = 80;  // Actual world size (double viewport)
let WORLD_HEIGHT = 60; // Actual world size (double viewport)

const TILE = {
    DOOR: 0,
    FLOOR: 1,
    WALL: 2,
};

const game = {
    camera: { x: 0, y: 0 }, // Camera position in world coordinates
    currentLevel: 1,
    enemies: [],
    gameRunning: true,
    items: [],
    map: [],
    player: {
		exp: 0,
		health: 100,
		level: 1,
		maxHealth: 100,
		x: 0,
		y: 0,
	},
    rooms: [],
    turnCount: 0,
};

// Map generation
function generateDungeon() {
    // Initialize world map with walls (double viewport size)
    game.map = [];
    for (let y = 0; y < WORLD_HEIGHT; y++) {
        game.map[y] = [];
        for (let x = 0; x < WORLD_WIDTH; x++) {
            game.map[y][x] = TILE.WALL;
        }
    }

    game.rooms = [];

    // Generate more rooms for the larger world (16-24 rooms)
    const roomCount = Math.floor(Math.random() * 9) + 16;

    for (let i = 0; i < roomCount; i++) {
        const room = generateRoom();
        if (room && !roomOverlaps(room)) {
            game.rooms.push(room);
            carveRoom(room);
        }
    }

    connectRooms();

    // Place player in first room
    if (game.rooms.length > 0) {
        const firstRoom = game.rooms[0];
        game.player.x = Math.floor(firstRoom.x + firstRoom.width / 2);
        game.player.y = Math.floor(firstRoom.y + firstRoom.height / 2);

        // Center camera on player
        updateCamera();
    }

    generateEnemies();
    generateItems();
}

function generateRoom() {
    let attempts = 0;
    while (attempts < 100) {
        const width = Math.floor(Math.random() * 8) + 4; // 4-11 wide
        const height = Math.floor(Math.random() * 6) + 4; // 4-9 tall
        const x = Math.floor(Math.random() * (WORLD_WIDTH - width - 2)) + 1;
        const y = Math.floor(Math.random() * (WORLD_HEIGHT - height - 2)) + 1;
        const room = { x: x, y: y, width: width, height: height };
        if (!roomOverlaps(room)) {
            return room;
        }
        attempts++;
    }
    return null;
}

function roomOverlaps(newRoom) {
    for (let i = 0; i < game.rooms.length; i++) {
        const room = game.rooms[i];
        if (newRoom.x < room.x + room.width + 1 &&
            newRoom.x + newRoom.width + 1 > room.x &&
            newRoom.y < room.y + room.height + 1 &&
            newRoom.y + newRoom.height + 1 > room.y) {
            return true;
        }
    }
    return false;
}

function carveRoom(room) {
    for (let y = room.y; y < room.y + room.height; y++) {
        for (let x = room.x; x < room.x + room.width; x++) {
            game.map[y][x] = TILE.FLOOR;
        }
    }
}

function connectRooms() {
    for (let i = 1; i < game.rooms.length; i++) {
        const prevRoom = game.rooms[i - 1];
        const currRoom = game.rooms[i];

        const prevCenter = {
            x: Math.floor(prevRoom.x + prevRoom.width / 2),
            y: Math.floor(prevRoom.y + prevRoom.height / 2)
        };
        const currCenter = {
            x: Math.floor(currRoom.x + currRoom.width / 2),
            y: Math.floor(currRoom.y + currRoom.height / 2)
        };

        // Create L-shaped corridor
        if (Math.random() < 0.5) {
            // Horizontal first, then vertical
            createHorizontalTunnel(prevCenter.x, currCenter.x, prevCenter.y);
            createVerticalTunnel(prevCenter.y, currCenter.y, currCenter.x);
        } else {
            // Vertical first, then horizontal
            createVerticalTunnel(prevCenter.y, currCenter.y, prevCenter.x);
            createHorizontalTunnel(prevCenter.x, currCenter.x, currCenter.y);
        }
    }
}

function createHorizontalTunnel(x1, x2, y) {
    const minX = Math.min(x1, x2);
    const maxX = Math.max(x1, x2);
    for (let x = minX; x <= maxX; x++) {
        if (x >= 0 && x < WORLD_WIDTH && y >= 0 && y < WORLD_HEIGHT) {
            game.map[y][x] = TILE.FLOOR;
        }
    }
}

function createVerticalTunnel(y1, y2, x) {
    const minY = Math.min(y1, y2);
    const maxY = Math.max(y1, y2);
    for (let y = minY; y <= maxY; y++) {
        if (x >= 0 && x < WORLD_WIDTH && y >= 0 && y < WORLD_HEIGHT) {
            game.map[y][x] = TILE.FLOOR;
        }
    }
}

function generateEnemies() {
    game.enemies = [];
    const enemyCount = Math.floor(Math.random() * 16) + 10; // 10-25 enemies for larger world

    for (let i = 0; i < enemyCount; i++) {
        const room = game.rooms[Math.floor(Math.random() * game.rooms.length)];
        const x = room.x + Math.floor(Math.random() * room.width);
        const y = room.y + Math.floor(Math.random() * room.height);

        // Don't spawn on player
        if (x !== game.player.x || y !== game.player.y) {
            game.enemies.push({
                x: x,
                y: y,
                health: 20 + Math.floor(Math.random() * 20),
                maxHealth: 40,
                damage: 5 + Math.floor(Math.random() * 5),
                type: Math.random() < 0.7 ? 'goblin' : 'orc'
            });
        }
    }
}

function generateItems() {
    game.items = [];
    const itemCount = Math.floor(Math.random() * 12) + 6; // 6-17 items for larger world

    for (let i = 0; i < itemCount; i++) {
        const room = game.rooms[Math.floor(Math.random() * game.rooms.length)];
        const x = room.x + Math.floor(Math.random() * room.width);
        const y = room.y + Math.floor(Math.random() * room.height);

        const itemType = Math.random();
        const item = { x, y };

        if (itemType < 0.4) {
            item.type = 'health_potion';
            item.name = 'Health Potion';
            item.healing = 25;
        } else if (itemType < 0.7) {
            item.type = 'gold';
            item.name = 'Gold';
            item.value = Math.floor(Math.random() * 50) + 10;
        } else {
            item.type = 'weapon';
            item.name = 'Magic Sword';
            item.damage = Math.floor(Math.random() * 10) + 5;
        }

        game.items.push(item);
    }
}

// Input handling
function handleKeyPress(key) {
    if (!game.gameRunning) return;

    let newX = game.player.x;
    let newY = game.player.y;
    let moved = false;

    switch (key) {
        case 'ArrowUp':
        case 'w':
            newY--;
            moved = true;
            break;
        case 'ArrowDown':
        case 's':
            newY++;
            moved = true;
            break;
        case 'ArrowLeft':
        case 'a':
            newX--;
            moved = true;
            break;
        case 'ArrowRight':
        case 'd':
            newX++;
            moved = true;
            break;
        case 'r':
            generateDungeon();
            return;
    }

    if (moved && isValidMove(newX, newY)) {
        game.player.x = newX;
        game.player.y = newY;

        // Update camera to follow player
        updateCamera();

        checkForItems();
        checkForCombat();
        if (game.gameRunning) {
            enemyTurn();
        }
        game.turnCount++;
    }
}

function isValidMove(x, y) {
    return x >= 0 && x < WORLD_WIDTH && y >= 0 && y < WORLD_HEIGHT && game.map[y][x] !== TILE.WALL;
}

function checkForItems() {
    for (let i = game.items.length - 1; i >= 0; i--) {
        const item = game.items[i];
        if (item.x === game.player.x && item.y === game.player.y) {
            if (item.type === 'health_potion') {
                game.player.health = Math.min(game.player.maxHealth, game.player.health + item.healing);
            } else if (item.type === 'gold') {
                game.player.exp += item.value;
                if (game.player.exp >= game.player.level * 100) {
                    game.player.level++;
                    game.player.maxHealth += 10;
                    game.player.health = game.player.maxHealth;
                }
            }
            game.items.splice(i, 1);
        }
    }
}

function checkForCombat() {
    for (let i = 0; i < game.enemies.length; i++) {
        const enemy = game.enemies[i];
        if (enemy.x === game.player.x && enemy.y === game.player.y) {
            const playerDamage = 10 + Math.floor(Math.random() * 10);
            enemy.health -= playerDamage;
            if (enemy.health <= 0) {
                game.enemies.splice(i, 1);
                game.player.exp += 15;
                if (game.player.exp >= game.player.level * 100) {
                    game.player.level++;
                    game.player.maxHealth += 10;
                    game.player.health = game.player.maxHealth;
                }
            } else {
                const enemyDamage = enemy.damage + Math.floor(Math.random() * 5);
                game.player.health -= enemyDamage;
                if (game.player.health <= 0) {
                    game.gameRunning = false;
                }
            }
            break;
        }
    }
}

function enemyTurn() {
    for (let i = 0; i < game.enemies.length; i++) {
        const enemy = game.enemies[i];

        // Simple AI: move towards player if in same room
        const playerRoom = getRoomAt(game.player.x, game.player.y);
        const enemyRoom = getRoomAt(enemy.x, enemy.y);

        if (playerRoom === enemyRoom && playerRoom !== null) {
            const dx = game.player.x - enemy.x;
            const dy = game.player.y - enemy.y;

            if (Math.abs(dx) > Math.abs(dy)) {
                enemy.x += dx > 0 ? 1 : -1;
            } else {
                enemy.y += dy > 0 ? 1 : -1;
            }

            // Make sure enemy doesn't move into walls or out of bounds
            if (!isValidMove(enemy.x, enemy.y)) {
                // Revert the move
                enemy.x = enemy.x - (dx > 0 ? 1 : -1);
                enemy.y = enemy.y - (dy > 0 ? 1 : -1);
            }
        }
    }
}

function getRoomAt(x, y) {
    for (let i = 0; i < game.rooms.length; i++) {
        const room = game.rooms[i];
        if (x >= room.x && x < room.x + room.width &&
            y >= room.y && y < room.y + room.height) {
            return i;
        }
    }
    return null;
}

// Camera system functions
function updateCamera() {
    // Center camera on player position
    game.camera.x = game.player.x;
    game.camera.y = game.player.y;
}

function worldToScreen(worldX, worldY) {
    // Convert world coordinates to screen coordinates
    const screenCenterX = Math.floor(MAP_WIDTH / 2);
    const screenCenterY = Math.floor(MAP_HEIGHT / 2);

    return {
        x: worldX - game.camera.x + screenCenterX,
        y: worldY - game.camera.y + screenCenterY
    };
}

function isVisible(worldX, worldY) {
    const screen = worldToScreen(worldX, worldY);
    return screen.x >= -1 && screen.x <= MAP_WIDTH && screen.y >= -1 && screen.y <= MAP_HEIGHT;
}

var setup = function(){
	fullScreenCanvas();
    calculateMapDimensions();
    generateDungeon();

    document.addEventListener('keydown', function(e) {
        handleKeyPress(e.key);
        e.preventDefault();
    });

    window.addEventListener('resize', function() {
        setTimeout(function() {
            calculateMapDimensions();
            generateDungeon();
        }, 100);
    });
};

function calculateMapDimensions() {
    // Reserve space for UI at the bottom
    const uiHeight = 80;
    const availableHeight = maxHeight - uiHeight;

    // Calculate how many tiles can fit with a reasonable minimum size
    const minTileSize = 12;
    const maxTileSize = 30;

    // Try to fit around 40 tiles width-wise, but adjust based on screen
    const desiredMapWidth = 40;
    let calculatedTileSize = Math.floor(maxWidth / desiredMapWidth);

    // Clamp tile size to reasonable bounds
    TILE_SIZE = Math.max(minTileSize, Math.min(maxTileSize, calculatedTileSize));

    // Calculate viewport dimensions based on the tile size
    MAP_WIDTH = Math.floor(maxWidth / TILE_SIZE);
    MAP_HEIGHT = Math.floor(availableHeight / TILE_SIZE);

    // Ensure minimum viewport size for playability
    MAP_WIDTH = Math.max(20, MAP_WIDTH);
    MAP_HEIGHT = Math.max(15, MAP_HEIGHT);

    // Create world that's double the viewport size in all directions
    WORLD_WIDTH = MAP_WIDTH * 2;
    WORLD_HEIGHT = MAP_HEIGHT * 2;

    console.log(`Screen: ${maxWidth}x${maxHeight}, Tiles: ${TILE_SIZE}px, Viewport: ${MAP_WIDTH}x${MAP_HEIGHT}, World: ${WORLD_WIDTH}x${WORLD_HEIGHT}`);
}

var draw = function(){
    background(0, 0, 0);

    // Calculate visible world bounds
    const viewCenterX = Math.floor(MAP_WIDTH / 2);
    const viewCenterY = Math.floor(MAP_HEIGHT / 2);
    const worldStartX = game.camera.x - viewCenterX - 1;
    const worldStartY = game.camera.y - viewCenterY - 1;
    const worldEndX = game.camera.x + viewCenterX + 1;
    const worldEndY = game.camera.y + viewCenterY + 1;

    // Draw map (only visible tiles)
    for (let worldY = Math.max(0, worldStartY); worldY < Math.min(game.map.length, worldEndY); worldY++) {
        for (let worldX = Math.max(0, worldStartX); worldX < Math.min(game.map[0].length, worldEndX); worldX++) {
            const screen = worldToScreen(worldX, worldY);

            // Skip if off screen
            if (screen.x < -1 || screen.x >= MAP_WIDTH || screen.y < -1 || screen.y >= MAP_HEIGHT) continue;

            const tile = game.map[worldY][worldX];
            const screenX = screen.x * TILE_SIZE;
            const screenY = screen.y * TILE_SIZE;

            switch (tile) {
                case TILE.WALL:
                    fill(100, 100, 100); // Gray walls
                    break;
                case TILE.FLOOR:
                    fill(200, 180, 140); // Light brown floor
                    break;
                case TILE.DOOR:
                    fill(139, 69, 19); // Brown door
                    break;
            }

            noStroke();
            rect(screenX, screenY, TILE_SIZE, TILE_SIZE);
        }
    }

    // Draw items (only visible ones)
    for (let i = 0; i < game.items.length; i++) {
        const item = game.items[i];

        if (!isVisible(item.x, item.y)) continue;

        const screen = worldToScreen(item.x, item.y);
        const screenX = screen.x * TILE_SIZE + TILE_SIZE / 2;
        const screenY = screen.y * TILE_SIZE + TILE_SIZE / 2;

        if (item.type === 'health_potion') {
            fill(255, 0, 0); // Red potion
        } else if (item.type === 'gold') {
            fill(255, 215, 0); // Gold
        } else {
            fill(192, 192, 192); // Silver weapon
        }

        noStroke();
        ellipse(screenX, screenY, TILE_SIZE / 2, TILE_SIZE / 2);
    }

    // Draw enemies (only visible ones)
    for (let i = 0; i < game.enemies.length; i++) {
        const enemy = game.enemies[i];

        if (!isVisible(enemy.x, enemy.y)) continue;

        const screen = worldToScreen(enemy.x, enemy.y);
        const screenX = screen.x * TILE_SIZE + TILE_SIZE / 2;
        const screenY = screen.y * TILE_SIZE + TILE_SIZE / 2;

        if (enemy.type === 'goblin') {
            fill(0, 150, 0); // Green goblin
        } else {
            fill(150, 0, 0); // Red orc
        }

        noStroke();
        ellipse(screenX, screenY, TILE_SIZE / 2, TILE_SIZE / 2);
    }

    // Draw player (always at screen center)
    const playerCenterX = Math.floor(MAP_WIDTH / 2);
    const playerCenterY = Math.floor(MAP_HEIGHT / 2);
    const playerScreenX = playerCenterX * TILE_SIZE + TILE_SIZE / 2;
    const playerScreenY = playerCenterY * TILE_SIZE + TILE_SIZE / 2;
    fill(0, 0, 255); // Blue player
    noStroke();
    ellipse(playerScreenX, playerScreenY, TILE_SIZE / 2, TILE_SIZE / 2);

    // Draw UI
    const uiStartY = MAP_HEIGHT * TILE_SIZE + 30;
    const fontSize = Math.max(12, Math.floor(TILE_SIZE * 0.6)); // Scale font with tile size
    textSize(fontSize);

    fill(255, 255, 255);
    text('Health: ' + game.player.health + '/' + game.player.maxHealth, 10, uiStartY);
    text('Level: ' + game.player.level, 150, uiStartY);
    text('Exp: ' + game.player.exp, 220, uiStartY);
    text('Turn: ' + game.turnCount, 320, uiStartY);
    text('Pos: ' + game.player.x + ',' + game.player.y, 400, uiStartY);

    if (!game.gameRunning) {
        fill(255, 0, 0);
        text('GAME OVER! Press R to restart', 10, uiStartY + fontSize + 10);
    } else {
        fill(200, 200, 200);
        text('Use WASD or arrow keys to move. R to regenerate dungeon.', 10, uiStartY + fontSize + 10);
    }
};

window.onload = function(){
	window.canvas = new Canvas(document.getElementById("canvas1"));
	window.ctx = canvas.ctx;
	canvas.setup = window.setup;
	canvas.draw = window.draw;
	canvas.run();
};
</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-42786295-1"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-42786295-1');
</script>
</body>
</html>
