<!--
 ::::::::  :::::::::  ::::::::::     ::: ::::::::::: :::::::::: :::::::::       :::::::::  :::   :::                               
:+:    :+: :+:    :+: :+:          :+: :+:   :+:     :+:        :+:    :+:      :+:    :+: :+:   :+: :+:                           
+:+        +:+    +:+ +:+         +:+   +:+  +:+     +:+        +:+    +:+      +:+    +:+  +:+ +:+                                
+#+        +#++:++#:  +#++:++#   +#++:++#++: +#+     +#++:++#   +#+    +:+      +#++:++#+    +#++:                                 
+#+        +#+    +#+ +#+        +#+     +#+ +#+     +#+        +#+    +#+      +#+    +#+    +#+                                  
#+#    #+# #+#    #+# #+#        #+#     #+# #+#     #+#        #+#    #+#      #+#    #+#    #+#    #+#                           
 ########  ###    ### ########## ###     ### ###     ########## #########       #########     ###                                  
                                                                                                                                   
                                                                                                                                   
                                                                                                                                   
    :::     ::::    ::: :::::::::  :::::::::  :::::::::: :::       :::       ::::::::  :::::::::: :::::::::   :::::::: ::::::::::: 
  :+: :+:   :+:+:   :+: :+:    :+: :+:    :+: :+:        :+:       :+:      :+:    :+: :+:        :+:    :+: :+:    :+:    :+:     
 +:+   +:+  :+:+:+  +:+ +:+    +:+ +:+    +:+ +:+        +:+       +:+      +:+        +:+        +:+    +:+ +:+           +:+     
+#++:++#++: +#+ +:+ +#+ +#+    +:+ +#++:++#:  +#++:++#   +#+  +:+  +#+      :#:        +#++:++#   +#++:++#:  +#++:++#++    +#+     
+#+     +#+ +#+  +#+#+# +#+    +#+ +#+    +#+ +#+        +#+ +#+#+ +#+      +#+   +#+# +#+        +#+    +#+        +#+    +#+     
#+#     #+# #+#   #+#+# #+#    #+# #+#    #+# #+#         #+#+# #+#+#       #+#    #+# #+#        #+#    #+# #+#    #+#    #+#     
###     ### ###    #### #########  ###    ### ##########   ###   ###         ########  ########## ###    ###  ########     ###     
-->
<!DOCTYPE html><html><head><meta charset="utf-8">
<title>Dungeon Explorer (via Canvas Engine)</title>
<script src="canvasengine.js"></script>
<style>
body {
    margin: 0;
    padding: 0;
}

#canvaspane {
    cursor: default;
}
</style>
</head>
<body>
<div id="content">
<div id="canvaspane">
<canvas id="canvas1" width="100" height="100"></canvas>
</div>
</div>
<script>
let TILE_SIZE = 20;
let VIEWPORT_WIDTH = 40;
let VIEWPORT_HEIGHT = 30;
let WORLD_WIDTH = VIEWPORT_WIDTH * 2;
let WORLD_HEIGHT = VIEWPORT_HEIGHT * 2;
let DEBUG_MODE = false;
let DEBUG_LOG_1 = '';
let DEBUG_LOG_2 = '';

const TILE = {
    DOOR: 0,
    FLOOR: 1,
    WALL: 2,
};

class Player {
    constructor(x = 0, y = 0) {
        this.x = x;
        this.y = y;
        this.health = 100;
        this.maxHealth = 100;
        this.level = 1;
        this.exp = 0;
    }

    move(newX, newY) {
        this.x = newX;
        this.y = newY;
    }

    takeDamage(damage) {
        this.health -= damage;
        return this.health <= 0;
    }

    heal(amount) {
        this.health = Math.min(this.maxHealth, this.health + amount);
    }

    gainExp(amount) {
        this.exp += amount;
        if (this.exp >= this.level * 100) {
            this.level++;
            this.maxHealth += 10;
            this.health = this.maxHealth;
            return true;
        }
        return false;
    }
}

class Enemy {
    constructor(x, y, type = 'goblin') {
        this.x = x;
        this.y = y;
        this.type = type;
        this.health = type === 'goblin' ? 20 + Math.floor(Math.random() * 20) : 30 + Math.floor(Math.random() * 20);
        this.maxHealth = 40;
        this.damage = 5 + Math.floor(Math.random() * 5);
    }

    moveTowards(targetX, targetY, world) {
        const dx = targetX - this.x;
        const dy = targetY - this.y;

        let newX = this.x;
        let newY = this.y;

        if (Math.abs(dx) > Math.abs(dy)) {
            newX += dx > 0 ? 1 : -1;
        } else {
            newY += dy > 0 ? 1 : -1;
        }

        if (world.isValidMove(newX, newY)) {
            this.x = newX;
            this.y = newY;
        }
    }

    takeDamage(damage) {
        this.health -= damage;
        return this.health <= 0;
    }
}

class Item {
    constructor(x, y, type = 'health_potion') {
        this.x = x;
        this.y = y;
        this.type = type;

        switch (type) {
            case 'health_potion':
                this.name = 'Health Potion';
                this.healing = 25;
                break;
            case 'gold':
                this.name = 'Gold';
                this.value = Math.floor(Math.random() * 50) + 10;
                break;
            case 'weapon':
                this.name = 'Magic Sword';
                this.damage = Math.floor(Math.random() * 10) + 5;
                break;
        }
    }

    use(player) {
        switch (this.type) {
            case 'health_potion':
                player.heal(this.healing);
                break;
            case 'gold':
                return player.gainExp(this.value);
            case 'weapon':
                return player.gainExp(this.damage);
        }
        return false;
    }
}

class Camera {
    constructor() {
        this.x = 0;
        this.y = 0;
    }

    follow(target) {
        this.x = target.x;
        this.y = target.y;
    }

    worldToScreen(worldX, worldY) {
        const screenCenterX = Math.floor(VIEWPORT_WIDTH / 2);
        const screenCenterY = Math.floor(VIEWPORT_HEIGHT / 2);

        return {
            x: worldX - this.x + screenCenterX,
            y: worldY - this.y + screenCenterY,
        };
    }

    isVisible(worldX, worldY) {
        const screen = this.worldToScreen(worldX, worldY);
        return screen.x >= 0 && screen.x < VIEWPORT_WIDTH && screen.y >= 0 && screen.y < VIEWPORT_HEIGHT;
    }
}

class World {
    constructor(width, height) {
        this.width = width;
        this.height = height;
        this.map = [];
        this.rooms = [];
    }

    generate() {
        this.generateWorldMap();
        this.generateRooms();
        this.connectRooms();
    }

    generateWorldMap() {
        this.map = [];
        for (let y = 0; y < this.height; y++) {
            this.map[y] = [];
            for (let x = 0; x < this.width; x++) {
                this.map[y][x] = TILE.WALL;
            }
        }
    }

    generateRooms() {
        this.rooms = [];
        const roomCount = Math.floor(Math.random() * 9) + 16;
        for (let i = 0; i < roomCount; i++) {
            const room = this.generateRoom();
            if (room && !this.roomOverlaps(room)) {
                this.rooms.push(room);
                this.carveRoom(room);
            }
        }
    }

    generateRoom() {
        let attempts = 0;
        while (attempts < 100) {
            const width = Math.floor(Math.random() * 8) + 4;
            const height = Math.floor(Math.random() * 6) + 4;
            const x = Math.floor(Math.random() * (this.width - width - 2)) + 1;
            const y = Math.floor(Math.random() * (this.height - height - 2)) + 1;
            const room = { x, y, width, height };
            if (!this.roomOverlaps(room)) {
                return room;
            }
            attempts++;
        }
        return null;
    }

    roomOverlaps(newRoom) {
        for (let i = 0; i < this.rooms.length; i++) {
            const room = this.rooms[i];
            if (newRoom.x < room.x + room.width + 1 &&
                newRoom.x + newRoom.width + 1 > room.x &&
                newRoom.y < room.y + room.height + 1 &&
                newRoom.y + newRoom.height + 1 > room.y) {
                return true;
            }
        }
        return false;
    }

    carveRoom(room) {
        for (let y = room.y; y < room.y + room.height; y++) {
            for (let x = room.x; x < room.x + room.width; x++) {
                this.map[y][x] = TILE.FLOOR;
            }
        }
    }

    connectRooms() {
        for (let i = 1; i < this.rooms.length; i++) {
            const prevRoom = this.rooms[i - 1];
            const currRoom = this.rooms[i];
            const prevCenter = {
                x: Math.floor(prevRoom.x + prevRoom.width / 2),
                y: Math.floor(prevRoom.y + prevRoom.height / 2),
            };
            const currCenter = {
                x: Math.floor(currRoom.x + currRoom.width / 2),
                y: Math.floor(currRoom.y + currRoom.height / 2),
            };
            if (Math.random() < 0.5) {
                this.createHorizontalTunnel(prevCenter.x, currCenter.x, prevCenter.y);
                this.createVerticalTunnel(prevCenter.y, currCenter.y, currCenter.x);
            } else {
                this.createVerticalTunnel(prevCenter.y, currCenter.y, prevCenter.x);
                this.createHorizontalTunnel(prevCenter.x, currCenter.x, currCenter.y);
            }
        }
    }

    createHorizontalTunnel(x1, x2, y) {
        const minX = Math.min(x1, x2);
        const maxX = Math.max(x1, x2);
        for (let x = minX; x <= maxX; x++) {
            if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
                this.map[y][x] = TILE.FLOOR;
            }
        }
    }

    createVerticalTunnel(y1, y2, x) {
        const minY = Math.min(y1, y2);
        const maxY = Math.max(y1, y2);
        for (let y = minY; y <= maxY; y++) {
            if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
                this.map[y][x] = TILE.FLOOR;
            }
        }
    }

    isValidMove(x, y) {
        return x >= 0 && x < this.width && y >= 0 && y < this.height && this.map[y][x] !== TILE.WALL;
    }

    getTileAt(x, y) {
        if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
            return this.map[y][x];
        }
        return TILE.WALL;
    }

    getRoomAt(x, y) {
        for (let i = 0; i < this.rooms.length; i++) {
            const room = this.rooms[i];
            if (x >= room.x && x < room.x + room.width && y >= room.y && y < room.y + room.height) {
                return i;
            }
        }
        return null;
    }

    isNearEdge(playerX, playerY, buffer = 10) {
        return {
            [CARDINAL_DIRECTION.NORTH]: playerY <= buffer,
            [CARDINAL_DIRECTION.SOUTH]: playerY >= this.height - buffer - 1,
            [CARDINAL_DIRECTION.WEST]: playerX <= buffer,
            [CARDINAL_DIRECTION.EAST]: playerX >= this.width - buffer - 1
        };
    }

    expandWorld(direction, expansionSize = 40) {
        let oldWidth = this.width;
        let oldHeight = this.height;
        let offsetX = 0;
        let offsetY = 0;

        // Calculate new dimensions and offsets
        switch (direction) {
            case CARDINAL_DIRECTION.NORTH:
                this.height += expansionSize;
                offsetY = expansionSize;
                WORLD_HEIGHT += expansionSize;
                break;
            case CARDINAL_DIRECTION.SOUTH:
                this.height += expansionSize;
                WORLD_HEIGHT += expansionSize;
                break;
            case CARDINAL_DIRECTION.WEST:
                this.width += expansionSize;
                offsetX = expansionSize;
                WORLD_WIDTH += expansionSize;
                break;
            case CARDINAL_DIRECTION.EAST:
                this.width += expansionSize;
                WORLD_WIDTH += expansionSize;
                break;
        }

        // Create new larger map
        let newMap = [];
        for (let y = 0; y < this.height; y++) {
            newMap[y] = [];
            for (let x = 0; x < this.width; x++) {
                newMap[y][x] = TILE.WALL;
            }
        }

        // Copy existing map to new position
        for (let y = 0; y < oldHeight; y++) {
            for (let x = 0; x < oldWidth; x++) {
                newMap[y + offsetY][x + offsetX] = this.map[y][x];
            }
        }

        // Update room positions if there's an offset
        if (offsetX > 0 || offsetY > 0) {
            for (let room of this.rooms) {
                room.x += offsetX;
                room.y += offsetY;
            }
        }

        this.map = newMap;

        // Generate new rooms in the expanded area
        this.generateNewRoomsInArea(direction, expansionSize, offsetX, offsetY, oldWidth, oldHeight);

        return { offsetX, offsetY };
    }

    generateNewRoomsInArea(direction, expansionSize, offsetX, offsetY, oldWidth, oldHeight) {
        let newRoomArea = {};

        // Define the area where new rooms should be generated
        switch (direction) {
            case CARDINAL_DIRECTION.NORTH:
                newRoomArea = { x: 0, y: 0, width: this.width, height: expansionSize };
                break;
            case CARDINAL_DIRECTION.SOUTH:
                newRoomArea = { x: 0, y: oldHeight + offsetY, width: this.width, height: expansionSize };
                break;
            case CARDINAL_DIRECTION.WEST:
                newRoomArea = { x: 0, y: 0, width: expansionSize, height: this.height };
                break;
            case CARDINAL_DIRECTION.EAST:
                newRoomArea = { x: oldWidth + offsetX, y: 0, width: expansionSize, height: this.height };
                break;
        }

        // Generate new rooms in the expansion area
        const roomCount = Math.floor(Math.random() * 6) + 8; // 8-13 new rooms
        let newRooms = [];

        for (let i = 0; i < roomCount; i++) {
            const room = this.generateRoomInArea(newRoomArea);
            if (room && !this.roomOverlaps(room)) {
                this.rooms.push(room);
                newRooms.push(room);
                this.carveRoom(room);
            }
        }

        // Connect new rooms to existing structure
        this.connectNewRoomsToExisting(newRooms, direction);
    }

    generateRoomInArea(area) {
        let attempts = 0;
        while (attempts < 50) {
            const width = Math.floor(Math.random() * 8) + 4;
            const height = Math.floor(Math.random() * 6) + 4;
            const x = Math.floor(Math.random() * (area.width - width - 2)) + area.x + 1;
            const y = Math.floor(Math.random() * (area.height - height - 2)) + area.y + 1;
            const room = { x, y, width, height };

            // Make sure room is within bounds
            if (x > 0 && y > 0 && x + width < this.width - 1 && y + height < this.height - 1) {
                return room;
            }
            attempts++;
        }
        return null;
    }

    connectNewRoomsToExisting(newRooms, direction) {
        if (newRooms.length === 0) return;

        // Find the closest existing room to connect to
        for (let newRoom of newRooms) {
            let closestExistingRoom = null;
            let minDistance = Infinity;

            for (let existingRoom of this.rooms) {
                // Skip if it's one of the new rooms
                if (newRooms.includes(existingRoom)) continue;

                const distance = Math.sqrt(Math.pow(newRoom.x - existingRoom.x, 2) + Math.pow(newRoom.y - existingRoom.y, 2));

                if (distance < minDistance) {
                    minDistance = distance;
                    closestExistingRoom = existingRoom;
                }
            }

            // Connect new room to closest existing room
            if (closestExistingRoom) {
                const newCenter = {
                    x: Math.floor(newRoom.x + newRoom.width / 2),
                    y: Math.floor(newRoom.y + newRoom.height / 2)
                };
                const existingCenter = {
                    x: Math.floor(closestExistingRoom.x + closestExistingRoom.width / 2),
                    y: Math.floor(closestExistingRoom.y + closestExistingRoom.height / 2)
                };

                if (Math.random() < 0.5) {
                    this.createHorizontalTunnel(newCenter.x, existingCenter.x, newCenter.y);
                    this.createVerticalTunnel(newCenter.y, existingCenter.y, existingCenter.x);
                } else {
                    this.createVerticalTunnel(newCenter.y, existingCenter.y, newCenter.x);
                    this.createHorizontalTunnel(newCenter.x, existingCenter.x, existingCenter.y);
                }
            }
        }

        // Connect new rooms to each other
        for (let i = 1; i < newRooms.length; i++) {
            const prevRoom = newRooms[i - 1];
            const currRoom = newRooms[i];
            const prevCenter = {
                x: Math.floor(prevRoom.x + prevRoom.width / 2),
                y: Math.floor(prevRoom.y + prevRoom.height / 2)
            };
            const currCenter = {
                x: Math.floor(currRoom.x + currRoom.width / 2),
                y: Math.floor(currRoom.y + currRoom.height / 2)
            };
            if (Math.random() < 0.5) {
                this.createHorizontalTunnel(prevCenter.x, currCenter.x, prevCenter.y);
                this.createVerticalTunnel(prevCenter.y, currCenter.y, currCenter.x);
            } else {
                this.createVerticalTunnel(prevCenter.y, currCenter.y, prevCenter.x);
                this.createHorizontalTunnel(prevCenter.x, currCenter.x, currCenter.y);
            }
        }
    }
}

class Game {
    constructor() {
        this.world = new World(WORLD_WIDTH, WORLD_HEIGHT);
        this.player = new Player();
        this.camera = new Camera();
        this.enemies = [];
        this.items = [];
        this.currentLevel = 1;
        this.turnCount = 0;
        this.gameRunning = true;

        this.throttledProcessMovement = throttle((direction) => {
            this.processMovement(direction);
        }, 83); // ~5 frames ≈ 83ms at 60fps
        // NOTE: 1000ms / 60fps = 16.666ms per frame
        // NOTE: 83ms = ~5 frames at 60fps (83ms * 5 = 416.666ms)
        // NOTE: 167ms = ~10 frames at 60fps (167ms * 10 = 1666.666ms)
    }

    init() {
        this.generateDungeon();
    }

    generateDungeon() {
        this.world.generate();
        if (this.world.rooms.length > 0) {
            const centerRoom = this.findCenterMostRoom();
            this.player.x = Math.floor(centerRoom.x + centerRoom.width / 2);
            this.player.y = Math.floor(centerRoom.y + centerRoom.height / 2);
            this.camera.follow(this.player);
        }
        this.generateEnemies();
        this.generateItems();
    }

    findCenterMostRoom() {
        const worldCenterX = WORLD_WIDTH / 2;
        const worldCenterY = WORLD_HEIGHT / 2;

        let closestRoom = this.world.rooms[0];
        let minDistance = Infinity;

        for (let i = 0; i < this.world.rooms.length; i++) {
            const room = this.world.rooms[i];
            const roomCenterX = room.x + room.width / 2;
            const roomCenterY = room.y + room.height / 2;
            const distance = Math.sqrt(Math.pow(roomCenterX - worldCenterX, 2) +  Math.pow(roomCenterY - worldCenterY, 2));
            if (distance < minDistance) {
                minDistance = distance;
                closestRoom = room;
            }
        }

        return closestRoom;
    }

    generateEnemies() {
        this.enemies = [];
        const enemyCount = Math.floor(Math.random() * 16) + 10;

        for (let i = 0; i < enemyCount; i++) {
            const room = this.world.rooms[Math.floor(Math.random() * this.world.rooms.length)];
            const x = room.x + Math.floor(Math.random() * room.width);
            const y = room.y + Math.floor(Math.random() * room.height);

            if (x !== this.player.x || y !== this.player.y) {
                const type = Math.random() < 0.7 ? 'goblin' : 'orc';
                this.enemies.push(new Enemy(x, y, type));
            }
        }
    }

    generateItems() {
        this.items = [];
        const itemCount = Math.floor(Math.random() * 12) + 6;

        for (let i = 0; i < itemCount; i++) {
            const room = this.world.rooms[Math.floor(Math.random() * this.world.rooms.length)];
            const x = room.x + Math.floor(Math.random() * room.width);
            const y = room.y + Math.floor(Math.random() * room.height);

            const itemType = Math.random();
            let type;
            if (itemType < 0.4) {
                type = 'health_potion';
            } else if (itemType < 0.7) {
                type = 'gold';
            } else {
                type = 'weapon';
            }

            this.items.push(new Item(x, y, type));
        }
    }

    handleKeyDown() {
        if (!this.gameRunning) return;

        if (keyCode === keys.R) {
            this.generateDungeon();
            return;
        }

        let direction = null;
        switch (keyCode) {
            case keys.UP:
            case keys.W:
                direction = DIRECTION.UP;
                break;
            case keys.DOWN:
            case keys.S:
                direction = DIRECTION.DOWN;
                break;
            case keys.LEFT:
            case keys.A:
                direction = DIRECTION.LEFT;
                break;
            case keys.RIGHT:
            case keys.D:
                direction = DIRECTION.RIGHT;
                break;
        }

        if (direction) {
            this.processMovement(direction);
        }
    }

    handleSwipe() {
        if (!this.gameRunning) {
            if (swipeDirection === DIRECTION.UP) {
                this.generateDungeon();
            }
            return;
        }

        if (swipeDirection) {
            this.throttledProcessMovement(swipeDirection);
        }
    }

    processMovement(direction) {
        let newX = this.player.x;
        let newY = this.player.y;
        let moved = false;

        switch (direction) {
            case DIRECTION.UP:
                newY--;
                moved = true;
                break;
            case DIRECTION.DOWN:
                newY++;
                moved = true;
                break;
            case DIRECTION.LEFT:
                newX--;
                moved = true;
                break;
            case DIRECTION.RIGHT:
                newX++;
                moved = true;
                break;
        }

        if (moved && this.world.isValidMove(newX, newY)) {
            this.player.move(newX, newY);
            this.camera.follow(this.player);

            this.checkAndExpandWorld();
            this.checkForItems();
            this.checkForCombat();

            if (this.gameRunning) {
                this.enemyTurn();
            }

            this.turnCount++;
        }
    }

    checkForItems() {
        for (let i = this.items.length - 1; i >= 0; i--) {
            const item = this.items[i];
            if (item.x === this.player.x && item.y === this.player.y) {
                item.use(this.player);
                this.items.splice(i, 1);
            }
        }
    }

    checkForCombat() {
        for (let i = 0; i < this.enemies.length; i++) {
            const enemy = this.enemies[i];
            if (enemy.x === this.player.x && enemy.y === this.player.y) {
                const playerDamage = 10 + Math.floor(Math.random() * 10);
                if (enemy.takeDamage(playerDamage)) {
                    this.enemies.splice(i, 1);
                    this.player.gainExp(15);
                } else {
                    const enemyDamage = enemy.damage + Math.floor(Math.random() * 5);
                    if (this.player.takeDamage(enemyDamage)) {
                        this.gameRunning = false;
                    }
                }
                break;
            }
        }
    }

    enemyTurn() {
        for (let i = 0; i < this.enemies.length; i++) {
            const enemy = this.enemies[i];
            const playerRoom = this.world.getRoomAt(this.player.x, this.player.y);
            const enemyRoom = this.world.getRoomAt(enemy.x, enemy.y);
            if (playerRoom === enemyRoom && playerRoom !== null) {
                enemy.moveTowards(this.player.x, this.player.y, this.world);
            }
        }
    }

    draw() {
        background(0, 0, 0);
        this.drawMap();
        this.drawItems();
        this.drawEnemies();
        this.drawPlayer();
        this.drawUI();
        this.handleSwipe();
    }

    checkAndExpandWorld() {
        const expansionBuffer = 15;
        const edges = this.world.isNearEdge(this.player.x, this.player.y, expansionBuffer);
        let expanded = false;
        if (edges[CARDINAL_DIRECTION.NORTH]) {
            const result = this.world.expandWorld(CARDINAL_DIRECTION.NORTH);
            this.updateEntitiesAfterExpansion(result.offsetX, result.offsetY);
            expanded = true;
        } else if (edges[CARDINAL_DIRECTION.SOUTH]) {
            const result = this.world.expandWorld(CARDINAL_DIRECTION.SOUTH);
            this.updateEntitiesAfterExpansion(result.offsetX, result.offsetY);
            expanded = true;
        } else if (edges[CARDINAL_DIRECTION.WEST]) {
            const result = this.world.expandWorld(CARDINAL_DIRECTION.WEST);
            this.updateEntitiesAfterExpansion(result.offsetX, result.offsetY);
            expanded = true;
        } else if (edges[CARDINAL_DIRECTION.EAST]) {
            const result = this.world.expandWorld(CARDINAL_DIRECTION.EAST);
            this.updateEntitiesAfterExpansion(result.offsetX, result.offsetY);
            expanded = true;
        }
        if (expanded) {
            this.generateItemsInExpandedArea();
            this.generateEnemiesInExpandedArea();
        }
    }

    updateEntitiesAfterExpansion(offsetX, offsetY) {
        // Update player position
        if (offsetX > 0 || offsetY > 0) {
            this.player.x += offsetX;
            this.player.y += offsetY;
            this.camera.follow(this.player);

            // Update all existing items
            for (let item of this.items) {
                item.x += offsetX;
                item.y += offsetY;
            }

            // Update all existing enemies
            for (let enemy of this.enemies) {
                enemy.x += offsetX;
                enemy.y += offsetY;
            }
        }
    }

    generateItemsInExpandedArea() {
        // Add a few more items when world expands
        const newItemCount = Math.floor(Math.random() * 5) + 3; // 3-7 new items
        for (let i = 0; i < newItemCount; i++) {
            let x, y;
            let attempts = 0;
            do {
                x = Math.floor(Math.random() * this.world.width);
                y = Math.floor(Math.random() * this.world.height);
                attempts++;
            } while (!this.world.isValidMove(x, y) && attempts < 100);

            if (this.world.isValidMove(x, y)) {
                let type = 'health_potion';
                if (Math.random() < 0.3) {
                    type = 'gold';
                } else if (Math.random() < 0.1) {
                    type = 'weapon';
                }
                this.items.push(new Item(x, y, type));
            }
        }
    }

    generateEnemiesInExpandedArea() {
        // Add a few more enemies when world expands
        const newEnemyCount = Math.floor(Math.random() * 4) + 2; // 2-5 new enemies
        for (let i = 0; i < newEnemyCount; i++) {
            let x, y;
            let attempts = 0;
            do {
                x = Math.floor(Math.random() * this.world.width);
                y = Math.floor(Math.random() * this.world.height);
                attempts++;
            } while (!this.world.isValidMove(x, y) && attempts < 100);

            if (this.world.isValidMove(x, y)) {
                const type = Math.random() < 0.6 ? 'goblin' : 'orc';
                this.enemies.push(new Enemy(x, y, type));
            }
        }
    }

    drawMap() {
        const viewCenterX = Math.floor(VIEWPORT_WIDTH / 2);
        const viewCenterY = Math.floor(VIEWPORT_HEIGHT / 2);
        const worldStartX = this.camera.x - viewCenterX - 1;
        const worldStartY = this.camera.y - viewCenterY - 1;
        const worldEndX = this.camera.x + viewCenterX + 1;
        const worldEndY = this.camera.y + viewCenterY + 1;

        for (let worldY = Math.max(0, worldStartY); worldY < Math.min(this.world.map.length, worldEndY); worldY++) {
            for (let worldX = Math.max(0, worldStartX); worldX < Math.min(this.world.map[0].length, worldEndX); worldX++) {
                const screen = this.camera.worldToScreen(worldX, worldY);

                if (screen.x < -1 || screen.x >= VIEWPORT_WIDTH || screen.y < -1 || screen.y >= VIEWPORT_HEIGHT) continue;

                const tile = this.world.map[worldY][worldX];
                const screenX = screen.x * TILE_SIZE;
                const screenY = screen.y * TILE_SIZE;

                switch (tile) {
                    case TILE.WALL:
                        fill(100, 100, 100); // gray
                        break;
                    case TILE.FLOOR:
                        fill(200, 180, 140); // brown
                        break;
                    case TILE.DOOR:
                        fill(139, 69, 19); // brown
                        break;
                }

                noStroke();
                rect(screenX, screenY, TILE_SIZE, TILE_SIZE);
            }
        }
    }

    drawItems() {
        for (let i = 0; i < this.items.length; i++) {
            const item = this.items[i];

            if (!this.camera.isVisible(item.x, item.y)) continue;

            const screen = this.camera.worldToScreen(item.x, item.y);

            // Additional safety check to ensure items stay within game grid
            if (screen.x < 0 || screen.x >= VIEWPORT_WIDTH || screen.y < 0 || screen.y >= VIEWPORT_HEIGHT) continue;

            const screenX = screen.x * TILE_SIZE + TILE_SIZE / 2;
            const screenY = screen.y * TILE_SIZE + TILE_SIZE / 2;

            if (item.type === 'health_potion') {
                fill(255, 0, 0); // red
            } else if (item.type === 'gold') {
                fill(255, 215, 0); // gold
            } else {
                fill(192, 192, 192); // gray
            }

            noStroke();
            ellipse(screenX, screenY, TILE_SIZE / 2, TILE_SIZE / 2);
        }
    }

    drawEnemies() {
        for (let i = 0; i < this.enemies.length; i++) {
            const enemy = this.enemies[i];

            if (!this.camera.isVisible(enemy.x, enemy.y)) continue;

            const screen = this.camera.worldToScreen(enemy.x, enemy.y);

            // Additional safety check to ensure enemies stay within game grid
            if (screen.x < 0 || screen.x >= VIEWPORT_WIDTH || screen.y < 0 || screen.y >= VIEWPORT_HEIGHT) continue;

            const screenX = screen.x * TILE_SIZE + TILE_SIZE / 2;
            const screenY = screen.y * TILE_SIZE + TILE_SIZE / 2;

            if (enemy.type === 'goblin') {
                fill(0, 150, 0); // green
            } else {
                fill(150, 0, 0); // red
            }

            noStroke();
            ellipse(screenX, screenY, TILE_SIZE / 2, TILE_SIZE / 2);
        }
    }

    drawPlayer() {
        const playerCenterX = Math.floor(VIEWPORT_WIDTH / 2);
        const playerCenterY = Math.floor(VIEWPORT_HEIGHT / 2);
        const playerScreenX = playerCenterX * TILE_SIZE + TILE_SIZE / 2;
        const playerScreenY = playerCenterY * TILE_SIZE + TILE_SIZE / 2;
        fill(0, 0, 255); // blue
        noStroke();
        ellipse(playerScreenX, playerScreenY, TILE_SIZE / 2, TILE_SIZE / 2);
    }

    drawUI() {
        const uiStartY = VIEWPORT_HEIGHT * TILE_SIZE + 30;
        const fontSize = Math.max(12, Math.floor(TILE_SIZE * 0.6));
        textSize(fontSize);

        fill(255, 255, 255); // white

        if (DEBUG_MODE) {
            this.drawDebugUI(uiStartY, fontSize);
            return;
        }

        text('Health: ' + this.player.health + '/' + this.player.maxHealth, 10, uiStartY);
        text('Level: ' + this.player.level, 150, uiStartY);
        text('Exp: ' + this.player.exp, 220, uiStartY);
        text('Turn: ' + this.turnCount, 320, uiStartY);
        text('Pos: ' + this.player.x + ',' + this.player.y, 400, uiStartY);

        if (!this.gameRunning) {
            fill(255, 0, 0); // red
            text('GAME OVER! Press R to restart', 10, uiStartY + fontSize + 10);
        } else {
            fill(200, 200, 200); // gray
            text('Use WASD/arrow keys or swipe to move. R/swipe up to restart.', 10, uiStartY + fontSize + 10);
        }
    }

    drawDebugUI(uiStartY, fontSize) {
        text('Log: ' + DEBUG_LOG_1, 10, uiStartY);
        text('Log: ' + DEBUG_LOG_2, 10, uiStartY + fontSize + 10);
    }
}

function calculateMapDimensions() {
    // Reserve space for UI at the bottom
    const uiHeight = 80;
    const availableHeight = maxHeight - uiHeight;

    // Calculate how many tiles can fit with a reasonable minimum size
    const minTileSize = 12;
    const maxTileSize = 30;

    // Try to fit around 40 tiles width-wise, but adjust based on screen
    const desiredMapWidth = 40;
    let calculatedTileSize = Math.floor(maxWidth / desiredMapWidth);

    // Clamp tile size to reasonable bounds
    TILE_SIZE = Math.max(minTileSize, Math.min(maxTileSize, calculatedTileSize));

    // Calculate viewport dimensions based on the tile size
    VIEWPORT_WIDTH = Math.floor(maxWidth / TILE_SIZE);
    VIEWPORT_HEIGHT = Math.floor(availableHeight / TILE_SIZE);

    // Ensure minimum viewport size for playability
    VIEWPORT_WIDTH = Math.max(20, VIEWPORT_WIDTH);
    VIEWPORT_HEIGHT = Math.max(15, VIEWPORT_HEIGHT);

    // Create world that's double the viewport size in all directions
    WORLD_WIDTH = VIEWPORT_WIDTH * 2;
    WORLD_HEIGHT = VIEWPORT_HEIGHT * 2;

    console.log(`Screen: ${maxWidth}x${maxHeight}, Tiles: ${TILE_SIZE}px, Viewport: ${VIEWPORT_WIDTH}x${VIEWPORT_HEIGHT}, World: ${WORLD_WIDTH}x${WORLD_HEIGHT}`);
}

let game;

var setup = function(){
    fullScreenCanvas();
    calculateMapDimensions();

    game = new Game();
    game.init();
};

var draw = function(){
    if (game) {
        game.draw();
    }
};

var keyDown = function(){
    if (game) {
        game.handleKeyDown();
    }
};

var windowResized = debounce(function(){
    calculateMapDimensions();
    if (game) {
        game.generateDungeon();
    }
}, 500);

window.onload = function(){
    window.canvas = new Canvas(document.getElementById("canvas1"));
    window.ctx = canvas.ctx;
    canvas.setup = window.setup;
    canvas.draw = window.draw;
    canvas.run();
};
</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-42786295-1"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-42786295-1');
</script>
</body>
</html>
