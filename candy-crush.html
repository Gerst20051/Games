<!--
 ::::::::  :::::::::  ::::::::::     ::: ::::::::::: :::::::::: :::::::::       :::::::::  :::   :::                               
:+:    :+: :+:    :+: :+:          :+: :+:   :+:     :+:        :+:    :+:      :+:    :+: :+:   :+: :+:                           
+:+        +:+    +:+ +:+         +:+   +:+  +:+     +:+        +:+    +:+      +:+    +:+  +:+ +:+                                
+#+        +#++:++#:  +#++:++#   +#++:++#++: +#+     +#++:++#   +#+    +:+      +#++:++#+    +#++:                                 
+#+        +#+    +#+ +#+        +#+     +#+ +#+     +#+        +#+    +#+      +#+    +#+    +#+                                  
#+#    #+# #+#    #+# #+#        #+#     #+# #+#     #+#        #+#    #+#      #+#    #+#    #+#    #+#                           
 ########  ###    ### ########## ###     ### ###     ########## #########       #########     ###                                  
                                                                                                                                   
                                                                                                                                   
                                                                                                                                   
    :::     ::::    ::: :::::::::  :::::::::  :::::::::: :::       :::       ::::::::  :::::::::: :::::::::   :::::::: ::::::::::: 
  :+: :+:   :+:+:   :+: :+:    :+: :+:    :+: :+:        :+:       :+:      :+:    :+: :+:        :+:    :+: :+:    :+:    :+:     
 +:+   +:+  :+:+:+  +:+ +:+    +:+ +:+    +:+ +:+        +:+       +:+      +:+        +:+        +:+    +:+ +:+           +:+     
+#++:++#++: +#+ +:+ +#+ +#+    +:+ +#++:++#:  +#++:++#   +#+  +:+  +#+      :#:        +#++:++#   +#++:++#:  +#++:++#++    +#+     
+#+     +#+ +#+  +#+#+# +#+    +#+ +#+    +#+ +#+        +#+ +#+#+ +#+      +#+   +#+# +#+        +#+    +#+        +#+    +#+     
#+#     #+# #+#   #+#+# #+#    #+# #+#    #+# #+#         #+#+# #+#+#       #+#    #+# #+#        #+#    #+# #+#    #+#    #+#     
###     ### ###    #### #########  ###    ### ##########   ###   ###         ########  ########## ###    ###  ########     ###     
-->
<!DOCTYPE html><html><head><meta charset="utf-8">
<title>Candy Crush (via Canvas Engine)</title>
<script src="canvasengine.js"></script>
<script src="soundengine.js"></script>
<style>
body {
    margin: 0;
    overflow: hidden;
    padding: 0;
}

#canvaspane {
    cursor: default;
}
</style>
</head>
<body>
<div id="content">
<div id="canvaspane">
<canvas id="canvas1" width="100" height="100"></canvas>
</div>
</div>
<script>
const grids = [
    [
        [ 1, 1, 1, 1 ],
        [ 1, 1, 1, 1 ],
        [ 1, 1, 1, 1 ],
        [ 1, 1, 1, 1 ],
    ],
    [
        [ 1, 1, 1, 1, 1, 1 ],
        [ 1, 1, 1, 1, 1, 1 ],
        [ 1, 1, 1, 1, 1, 1 ],
        [ 1, 1, 1, 1, 1, 1 ],
        [ 1, 1, 1, 1, 1, 1 ],
        [ 1, 1, 1, 1, 1, 1 ],
    ],
    [
        [ 1, 1, 1, 1, 1, 1, 1, 1 ],
        [ 1, 1, 1, 1, 1, 1, 1, 1 ],
        [ 1, 1, 1, 1, 1, 1, 1, 1 ],
        [ 1, 1, 1, 1, 1, 1, 1, 1 ],
        [ 1, 1, 1, 1, 1, 1, 1, 1 ],
        [ 1, 1, 1, 1, 1, 1, 1, 1 ],
        [ 1, 1, 1, 1, 1, 1, 1, 1 ],
        [ 1, 1, 1, 1, 1, 1, 1, 1 ],
    ],
];

class Block {
    static types = [
        'images/emeralds/amethyst.png',
        'images/emeralds/aquamarine.png',
        'images/emeralds/clinohumite.png',
        'images/emeralds/diamond.png',
        'images/emeralds/emerald.png',
        'images/emeralds/mystic-topaz.png',
        'images/emeralds/peridot.png',
        'images/emeralds/ruby.png',
        'images/emeralds/sapphire.png',
    ];

    constructor(board, index, type) {
        this.board = board;
        this.index = index;
        this.type = type;
        this.computeCoordinates();
    }

    computeCoordinates() {
        const columnIndex = this.index % this.board.grid.length;
        const rowIndex = floor(this.index / this.board.grid.length);
        const blockXPos = this.board.blockDimensions * columnIndex;
        const blockYPos = this.board.blockDimensions * rowIndex;
        this.coordinates = {
            x: blockXPos + this.board.offset.x,
            y: blockYPos + this.board.offset.y,
        };
    }

    draw() {
        image(this.type, this.coordinates.x, this.coordinates.y, this.board.blockDimensions, this.board.blockDimensions);
    }
}

class Board {
    numberOfBlockTypes = 4;
    blockTypes = [];
    blocks = [];
    gridIndex = 2;

    constructor() {
        this.grid = grids[this.gridIndex];
        this.calculateDimensions();
        this.buildBlocks();
    }

    calculateDimensions() {
        const minBoardSize = min(maxHeight, maxWidth);
        this.dimensions = {
            height: minBoardSize,
            width: minBoardSize,
        };
        this.offset = {
            x: maxWidth > this.dimensions.width ? (maxWidth - this.dimensions.width) / 2 : 0,
            y: maxHeight > this.dimensions.height ? (maxHeight - this.dimensions.height) / 2 : 0,
        };
        this.blockDimensions = this.dimensions.height / this.grid.length;
    }

    buildBlocks() {
        this.blocks = [];
        this.blockTypes = shuffle(Block.types).slice(0, this.numberOfBlockTypes);
        const numberOfBlocks = this.grid.length * this.grid.length;
        for (let i = 0; i < numberOfBlocks; i++) {
            this.blocks.push(new Block(this, i, randomElement(this.blockTypes)));
        }
    }

    draw() {
        this.blocks.forEach(block => block.draw());
    }
}

class Game {
    constructor() {
        this.board = new Board();
        this.dragState = {
            isDragging: false,
            startBlock: null,
            currentBlock: null,
            dragOffset: { x: 0, y: 0 }
        };
        this.matchCount = 0;
        this.matchCountThreshold = 25;
    }

    getBlockAtPosition(x, y) {
        for (let block of this.board.blocks) {
            if (x >= block.coordinates.x &&
                x <= block.coordinates.x + this.board.blockDimensions &&
                y >= block.coordinates.y &&
                y <= block.coordinates.y + this.board.blockDimensions
            ) {
                return block;
            }
        }
        return null;
    }

    areBlocksAdjacent(block1, block2) {
        if (!block1 || !block2) return false;

        const col1 = block1.index % this.board.grid.length;
        const row1 = floor(block1.index / this.board.grid.length);
        const col2 = block2.index % this.board.grid.length;
        const row2 = floor(block2.index / this.board.grid.length);

        const colDiff = Math.abs(col1 - col2);
        const rowDiff = Math.abs(row1 - row2);

        return (colDiff === 1 && rowDiff === 0) || (colDiff === 0 && rowDiff === 1);
    }

    swapBlocks(block1, block2) {
        if (!block1 || !block2) return;

        const tempType = block1.type;
        block1.type = block2.type;
        block2.type = tempType;
    }

    getIndexFor(row, col) {
        return row * this.board.grid.length + col;
    }

    getTypeAt(row, col) {
        return this.board.blocks[this.getIndexFor(row, col)].type;
    }

    setTypeAt(row, col, type) {
        this.board.blocks[this.getIndexFor(row, col)].type = type;
    }

    findMatches() {
        const n = this.board.grid.length;
        const matched = new Set();

        // horizontal runs
        for (let r = 0; r < n; r++) {
            let currentType = this.getTypeAt(r, 0);
            let runStart = 0;
            let runLen = 1;
            for (let c = 1; c < n; c++) {
                const t = this.getTypeAt(r, c);
                if (t === currentType) {
                    runLen++;
                } else {
                    if (runLen >= 3) {
                        for (let k = runStart; k < runStart + runLen; k++) {
                            matched.add(this.getIndexFor(r, k));
                        }
                    }
                    currentType = t;
                    runStart = c;
                    runLen = 1;
                }
            }
            if (runLen >= 3) {
                for (let k = runStart; k < runStart + runLen; k++) {
                    matched.add(this.getIndexFor(r, k));
                }
            }
        }

        // vertical runs
        for (let c = 0; c < n; c++) {
            let currentType = this.getTypeAt(0, c);
            let runStart = 0;
            let runLen = 1;
            for (let r = 1; r < n; r++) {
                const t = this.getTypeAt(r, c);
                if (t === currentType) {
                    runLen++;
                } else {
                    if (runLen >= 3) {
                        for (let k = runStart; k < runStart + runLen; k++) {
                            matched.add(this.getIndexFor(k, c));
                        }
                    }
                    currentType = t;
                    runStart = r;
                    runLen = 1;
                }
            }
            if (runLen >= 3) {
                for (let k = runStart; k < runStart + runLen; k++) {
                    matched.add(this.getIndexFor(k, c));
                }
            }
        }

        return matched;
    }

    applyMatches(matched) {
        const n = this.board.grid.length;

        for (let c = 0; c < n; c++) {
            const colTypes = [];
            // collect non-matching types from bottom to top
            for (let r = n - 1; r >= 0; r--) {
                const idx = this.getIndexFor(r, c);
                if (!matched.has(idx)) {
                    colTypes.push(this.getTypeAt(r, c));
                }
            }

            // write back non-matching types from bottom up
            let writeRow = n - 1;
            for (let i = 0; i < colTypes.length; i++) {
                this.setTypeAt(writeRow, c, colTypes[i]);
                writeRow--;
            }

            // fill remaining top cells with new random blocks
            for (; writeRow >= 0; writeRow--) {
                this.setTypeAt(writeRow, c, randomElement(this.board.blockTypes));
            }
        }
    }

    startDrag(x, y) {
        const block = this.getBlockAtPosition(x, y);
        if (block) {
            this.dragState.isDragging = true;
            this.dragState.startBlock = block;
            this.dragState.currentBlock = block;
            this.dragState.dragOffset.x = x - block.coordinates.x;
            this.dragState.dragOffset.y = y - block.coordinates.y;
        }
    }

    updateDrag(x, y) {
        if (!this.dragState.isDragging) return;

        const block = this.getBlockAtPosition(x, y);
        if (block && block !== this.dragState.startBlock) {
            this.dragState.currentBlock = block;
        }
    }

    endDrag() {
        if (this.dragState.isDragging &&
            this.dragState.startBlock &&
            this.dragState.currentBlock &&
            this.dragState.startBlock !== this.dragState.currentBlock
        ) {
            if (this.areBlocksAdjacent(this.dragState.startBlock, this.dragState.currentBlock)) {
                this.swapBlocks(this.dragState.startBlock, this.dragState.currentBlock);
                let matches = this.findMatches();
                if (matches.size === 0) {
                    this.swapBlocks(this.dragState.startBlock, this.dragState.currentBlock);
                } else {
                    while (matches.size > 0) {
                        this.matchCount++;
                        this.applyMatches(matches);
                        matches = this.findMatches();
                    }
                }
            }
        }

        this.dragState = {
            isDragging: false,
            startBlock: null,
            currentBlock: null,
            dragOffset: { x: 0, y: 0 }
        };

        if (this.matchCount >= this.matchCountThreshold) {
            this.matchCount = 0;
            this.board.buildBlocks();
        }
    }

    draw() {
        background(colors.black);
        this.board.draw();

        // Draw drag feedback
        if (this.dragState.isDragging && this.dragState.startBlock) {
            // Highlight the dragged block
            ctx.globalAlpha = 0.7;
            ctx.fillStyle = colors.white;
            ctx.fillRect(
                this.dragState.startBlock.coordinates.x - 2,
                this.dragState.startBlock.coordinates.y - 2,
                this.board.blockDimensions + 4,
                this.board.blockDimensions + 4
            );
            ctx.globalAlpha = 1.0;

            // Highlight potential swap target
            if (this.dragState.currentBlock &&
                this.dragState.currentBlock !== this.dragState.startBlock &&
                this.areBlocksAdjacent(this.dragState.startBlock, this.dragState.currentBlock)) {
                ctx.globalAlpha = 0.5;
                ctx.fillStyle = colors.green;
                ctx.fillRect(
                    this.dragState.currentBlock.coordinates.x - 2,
                    this.dragState.currentBlock.coordinates.y - 2,
                    this.board.blockDimensions + 4,
                    this.board.blockDimensions + 4
                );
                ctx.globalAlpha = 1.0;
            }
        }
    }
}

function setup() {
    window.game = new Game();
    fullScreenCanvas();
}

function draw() {
    window.game.draw();
}

function mousePressed() {
    window.game.startDrag(mouseX, mouseY);
}

function mouseMoved() {
    window.game.updateDrag(mouseX, mouseY);
}

function mouseReleased() {
    window.game.endDrag();
}

function touchStart() {
    window.game.startDrag(mouseX, mouseY);
}

function touchMoved() {
    window.game.updateDrag(mouseX, mouseY);
}

function touchEnd() {
    window.game.endDrag();
}

window.onload = function() {
    window.canvas = new Canvas(document.getElementById('canvas1'));
    window.ctx = canvas.ctx;
    canvas.setup = window.setup;
    canvas.draw = window.draw;
    canvas.run();
};

var windowResized = function() {
    window.game.board.calculateDimensions();
    window.game.board.blocks.forEach(block => block.computeCoordinates());
};

var orientationChanged = function() {
    windowResized();
};

// TODO: Missing Features
// - score calculation
// - animation
// - sound
// - level progression
</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-42786295-1"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-42786295-1');
</script>
</body>
</html>
