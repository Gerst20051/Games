<!--
 ::::::::  :::::::::  ::::::::::     ::: ::::::::::: :::::::::: :::::::::       :::::::::  :::   :::                               
:+:    :+: :+:    :+: :+:          :+: :+:   :+:     :+:        :+:    :+:      :+:    :+: :+:   :+: :+:                           
+:+        +:+    +:+ +:+         +:+   +:+  +:+     +:+        +:+    +:+      +:+    +:+  +:+ +:+                                
+#+        +#++:++#:  +#++:++#   +#++:++#++: +#+     +#++:++#   +#+    +:+      +#++:++#+    +#++:                                 
+#+        +#+    +#+ +#+        +#+     +#+ +#+     +#+        +#+    +#+      +#+    +#+    +#+                                  
#+#    #+# #+#    #+# #+#        #+#     #+# #+#     #+#        #+#    #+#      #+#    #+#    #+#    #+#                           
 ########  ###    ### ########## ###     ### ###     ########## #########       #########     ###                                  
                                                                                                                                   
                                                                                                                                   
                                                                                                                                   
    :::     ::::    ::: :::::::::  :::::::::  :::::::::: :::       :::       ::::::::  :::::::::: :::::::::   :::::::: ::::::::::: 
  :+: :+:   :+:+:   :+: :+:    :+: :+:    :+: :+:        :+:       :+:      :+:    :+: :+:        :+:    :+: :+:    :+:    :+:     
 +:+   +:+  :+:+:+  +:+ +:+    +:+ +:+    +:+ +:+        +:+       +:+      +:+        +:+        +:+    +:+ +:+           +:+     
+#++:++#++: +#+ +:+ +#+ +#+    +:+ +#++:++#:  +#++:++#   +#+  +:+  +#+      :#:        +#++:++#   +#++:++#:  +#++:++#++    +#+     
+#+     +#+ +#+  +#+#+# +#+    +#+ +#+    +#+ +#+        +#+ +#+#+ +#+      +#+   +#+# +#+        +#+    +#+        +#+    +#+     
#+#     #+# #+#   #+#+# #+#    #+# #+#    #+# #+#         #+#+# #+#+#       #+#    #+# #+#        #+#    #+# #+#    #+#    #+#     
###     ### ###    #### #########  ###    ### ##########   ###   ###         ########  ########## ###    ###  ########     ###     
-->
<!DOCTYPE html><html><head><meta charset="utf-8">
<title>Candy Crush (via Canvas Engine)</title>
<script src="canvasengine.js"></script>
<script src="soundengine.js"></script>
<style>
body {
    margin: 0;
    overflow: hidden;
    padding: 0;
}

#canvaspane {
    cursor: default;
}
</style>
</head>
<body>
<div id="content">
<div id="canvaspane">
<canvas id="canvas1" width="100" height="100"></canvas>
</div>
</div>
<script>
const grids = [
    [
        [ 1, 1, 1, 1 ],
        [ 1, 1, 1, 1 ],
        [ 1, 1, 1, 1 ],
        [ 1, 1, 1, 1 ],
    ],
    [
        [ 1, 1, 1, 1, 1, 1 ],
        [ 1, 1, 1, 1, 1, 1 ],
        [ 1, 1, 1, 1, 1, 1 ],
        [ 1, 1, 1, 1, 1, 1 ],
        [ 1, 1, 1, 1, 1, 1 ],
        [ 1, 1, 1, 1, 1, 1 ],
    ],
    [
        [ 1, 1, 1, 1, 1, 1, 1, 1 ],
        [ 1, 1, 1, 1, 1, 1, 1, 1 ],
        [ 1, 1, 1, 1, 1, 1, 1, 1 ],
        [ 1, 1, 1, 1, 1, 1, 1, 1 ],
        [ 1, 1, 1, 1, 1, 1, 1, 1 ],
        [ 1, 1, 1, 1, 1, 1, 1, 1 ],
        [ 1, 1, 1, 1, 1, 1, 1, 1 ],
        [ 1, 1, 1, 1, 1, 1, 1, 1 ],
    ],
];

class Block {
    static types = [
        'images/emeralds/amethyst.png',
        'images/emeralds/aquamarine.png',
        'images/emeralds/clinohumite.png',
        'images/emeralds/diamond.png',
        'images/emeralds/emerald.png',
        'images/emeralds/mystic-topaz.png',
        'images/emeralds/peridot.png',
        'images/emeralds/ruby.png',
        'images/emeralds/sapphire.png',
    ];

    constructor(board, index) {
        this.board = board;
        this.index = index;
        this.computeCoordinates();
        this.type = randomElement(Block.types);
    }

    computeCoordinates() {
        const columnIndex = this.index % this.board.grid.length;
        const rowIndex = floor(this.index / this.board.grid.length);
        const blockXPos = this.board.blockDimensions * columnIndex;
        const blockYPos = this.board.blockDimensions * rowIndex;
        this.coordinates = {
            x: blockXPos + this.board.offset.x,
            y: blockYPos + this.board.offset.y,
        };
    }

    draw() {
        image(this.type, this.coordinates.x, this.coordinates.y, this.board.blockDimensions, this.board.blockDimensions);
    }
}

class Board {
    blocks = [];
    gridIndex = 2;

    constructor() {
        this.grid = grids[this.gridIndex];
        this.calculateDimensions();
        this.buildBlocks();
    }

    calculateDimensions() {
        const minBoardSize = min(maxHeight, maxWidth);
        this.dimensions = {
            height: minBoardSize,
            width: minBoardSize,
        };
        this.offset = {
            x: maxWidth > this.dimensions.width ? (maxWidth - this.dimensions.width) / 2 : 0,
            y: maxHeight > this.dimensions.height ? (maxHeight - this.dimensions.height) / 2 : 0,
        };
        this.blockDimensions = this.dimensions.height / this.grid.length;
    }

    buildBlocks() {
        const numberOfBlocks = this.grid.length * this.grid.length;
        for (let i = 0; i < numberOfBlocks; i++) {
            this.blocks.push(new Block(this, i));
        }
    }

    draw() {
        this.blocks.forEach(block => block.draw());
    }
}

class Game {
    constructor() {
        this.board = new Board();
        this.dragState = {
            isDragging: false,
            startBlock: null,
            currentBlock: null,
            dragOffset: { x: 0, y: 0 }
        };
    }

    getBlockAtPosition(x, y) {
        for (let block of this.board.blocks) {
            if (x >= block.coordinates.x &&
                x <= block.coordinates.x + this.board.blockDimensions &&
                y >= block.coordinates.y &&
                y <= block.coordinates.y + this.board.blockDimensions
            ) {
                return block;
            }
        }
        return null;
    }

    areBlocksAdjacent(block1, block2) {
        if (!block1 || !block2) return false;

        const col1 = block1.index % this.board.grid.length;
        const row1 = floor(block1.index / this.board.grid.length);
        const col2 = block2.index % this.board.grid.length;
        const row2 = floor(block2.index / this.board.grid.length);

        const colDiff = Math.abs(col1 - col2);
        const rowDiff = Math.abs(row1 - row2);

        return (colDiff === 1 && rowDiff === 0) || (colDiff === 0 && rowDiff === 1);
    }

    swapBlocks(block1, block2) {
        if (!block1 || !block2) return;

        const tempType = block1.type;
        block1.type = block2.type;
        block2.type = tempType;
    }

    startDrag(x, y) {
        const block = this.getBlockAtPosition(x, y);
        if (block) {
            this.dragState.isDragging = true;
            this.dragState.startBlock = block;
            this.dragState.currentBlock = block;
            this.dragState.dragOffset.x = x - block.coordinates.x;
            this.dragState.dragOffset.y = y - block.coordinates.y;
        }
    }

    updateDrag(x, y) {
        if (!this.dragState.isDragging) return;

        const block = this.getBlockAtPosition(x, y);
        if (block && block !== this.dragState.startBlock) {
            this.dragState.currentBlock = block;
        }
    }

    endDrag() {
        if (this.dragState.isDragging &&
            this.dragState.startBlock &&
            this.dragState.currentBlock &&
            this.dragState.startBlock !== this.dragState.currentBlock
        ) {
            if (this.areBlocksAdjacent(this.dragState.startBlock, this.dragState.currentBlock)) {
                this.swapBlocks(this.dragState.startBlock, this.dragState.currentBlock);
            }
        }

        this.dragState = {
            isDragging: false,
            startBlock: null,
            currentBlock: null,
            dragOffset: { x: 0, y: 0 }
        };
    }

    draw() {
        background(colors.black);
        this.board.draw();

        // Draw drag feedback
        if (this.dragState.isDragging && this.dragState.startBlock) {
            // Highlight the dragged block
            ctx.globalAlpha = 0.7;
            ctx.fillStyle = colors.white;
            ctx.fillRect(
                this.dragState.startBlock.coordinates.x - 2,
                this.dragState.startBlock.coordinates.y - 2,
                this.board.blockDimensions + 4,
                this.board.blockDimensions + 4
            );
            ctx.globalAlpha = 1.0;

            // Highlight potential swap target
            if (this.dragState.currentBlock &&
                this.dragState.currentBlock !== this.dragState.startBlock &&
                this.areBlocksAdjacent(this.dragState.startBlock, this.dragState.currentBlock)) {
                ctx.globalAlpha = 0.5;
                ctx.fillStyle = colors.green;
                ctx.fillRect(
                    this.dragState.currentBlock.coordinates.x - 2,
                    this.dragState.currentBlock.coordinates.y - 2,
                    this.board.blockDimensions + 4,
                    this.board.blockDimensions + 4
                );
                ctx.globalAlpha = 1.0;
            }
        }
    }
}

function setup() {
    window.game = new Game();
    fullScreenCanvas();
}

function draw() {
    window.game.draw();
}

function mousePressed() {
    window.game.startDrag(mouseX, mouseY);
}

function mouseMoved() {
    window.game.updateDrag(mouseX, mouseY);
}

function mouseReleased() {
    window.game.endDrag();
}

function touchStart() {
    window.game.startDrag(mouseX, mouseY);
}

function touchMoved() {
    window.game.updateDrag(mouseX, mouseY);
}

function touchEnd() {
    window.game.endDrag();
}

window.onload = function() {
    window.canvas = new Canvas(document.getElementById('canvas1'));
    window.ctx = canvas.ctx;
    canvas.setup = window.setup;
    canvas.draw = window.draw;
    canvas.run();
};

var windowResized = function() {
    window.game.board.calculateDimensions();
    window.game.board.blocks.forEach(block => block.computeCoordinates());
};

var orientationChanged = function() {
    windowResized();
};
</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-42786295-1"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-42786295-1');
</script>
</body>
</html>
