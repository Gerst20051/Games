<!--
 ::::::::  :::::::::  ::::::::::     ::: ::::::::::: :::::::::: :::::::::       :::::::::  :::   :::                               
:+:    :+: :+:    :+: :+:          :+: :+:   :+:     :+:        :+:    :+:      :+:    :+: :+:   :+: :+:                           
+:+        +:+    +:+ +:+         +:+   +:+  +:+     +:+        +:+    +:+      +:+    +:+  +:+ +:+                                
+#+        +#++:++#:  +#++:++#   +#++:++#++: +#+     +#++:++#   +#+    +:+      +#++:++#+    +#++:                                 
+#+        +#+    +#+ +#+        +#+     +#+ +#+     +#+        +#+    +#+      +#+    +#+    +#+                                  
#+#    #+# #+#    #+# #+#        #+#     #+# #+#     #+#        #+#    #+#      #+#    #+#    #+#    #+#                           
 ########  ###    ### ########## ###     ### ###     ########## #########       #########     ###                                  
                                                                                                                                   
                                                                                                                                   
                                                                                                                                   
    :::     ::::    ::: :::::::::  :::::::::  :::::::::: :::       :::       ::::::::  :::::::::: :::::::::   :::::::: ::::::::::: 
  :+: :+:   :+:+:   :+: :+:    :+: :+:    :+: :+:        :+:       :+:      :+:    :+: :+:        :+:    :+: :+:    :+:    :+:     
 +:+   +:+  :+:+:+  +:+ +:+    +:+ +:+    +:+ +:+        +:+       +:+      +:+        +:+        +:+    +:+ +:+           +:+     
+#++:++#++: +#+ +:+ +#+ +#+    +:+ +#++:++#:  +#++:++#   +#+  +:+  +#+      :#:        +#++:++#   +#++:++#:  +#++:++#++    +#+     
+#+     +#+ +#+  +#+#+# +#+    +#+ +#+    +#+ +#+        +#+ +#+#+ +#+      +#+   +#+# +#+        +#+    +#+        +#+    +#+     
#+#     #+# #+#   #+#+# #+#    #+# #+#    #+# #+#         #+#+# #+#+#       #+#    #+# #+#        #+#    #+# #+#    #+#    #+#     
###     ### ###    #### #########  ###    ### ##########   ###   ###         ########  ########## ###    ###  ########     ###     
-->
<!DOCTYPE html><html><head><meta charset="utf-8">
<title>Light Rays (via Canvas Engine)</title>
<script src="canvasengine.js"></script>
<style>
body {
	margin: 0;
	padding: 0;
}

#canvaspane {
	cursor: default;
}
</style>
</head>
<body>
<div id="content">
<div id="canvaspane">
<canvas id="canvas1" width="100" height="100"></canvas>
</div>
</div>
<script>
const rays = [];
const speed = 5;
const numInitialRays = 100;
const maxRays = 2000;
const rayInterval = 10000;
const updateColorsDelay = 30000;
const numStars = 50;
let useRandomColors = false;
let reverseDirection = false;

var setup = function(){
	fullScreenCanvas();
	createRays(numInitialRays);
	createRaysInterval();
	updateColorsTimeout();
};

const createRaysInterval = function(){
	setInterval(function(){
		createRays(numInitialRays / 2);
		if (rays.length > maxRays) {
			rays.splice(0, rays.length - maxRays);
		}
	}, rayInterval);
};

const updateColorsTimeout = function(){
	setTimeout(function(){
		useRandomColors = true;
	}, updateColorsDelay);
};

const createRays = function(num){
	for (let i = 0; i < num; i++) {
		rays.push(createRay());
	}
};

const createRay = function(){
	const angle = randomDouble(0, TWO_PI);
	const distance = reverseDirection ? randomDouble(0, 100) : randomDouble(500, 1500);
	const color = useRandomColors ? randomGoldenRatioColor() : (randomBoolean() ? colors.white : '#4A90E2'); // white or blue
	const thickness = randomDouble(1, 4);
	const speed = randomDouble(3, 11);

	return {
		angle: angle,
		distance: distance,
		startDistance: distance,
		color: color,
		thickness: thickness,
		speed: speed,
		opacity: randomDouble(0.2, 1),
		reverse: reverseDirection
	};
};

const drawStars = function(){
	ctx.fillStyle = colors.white;
	for (let i = 0; i < numStars; i++) {
		const x = randomDouble(0, maxWidth);
		const y = randomDouble(0, maxHeight);
		const size = randomDouble(0, 2);
		ctx.globalAlpha = randomDouble(0.2, 1);
		ctx.fillRect(x, y, size, size);
		// alpha(randomDouble(0.2, 1));
		// rect(x, y, size, size);
	}
	// ctx.globalAlpha = 1.0;
	// alpha(1);
};

const drawRays = function(){
	const centerX = maxWidth / 2;
	const centerY = maxHeight / 2;

	for (let i = 0; i < rays.length; i++) {
		const ray = rays[i];

		// Calculate ray position
		const x1 = centerX + cos(ray.angle) * ray.distance;
		const y1 = centerY + sin(ray.angle) * ray.distance;
		const x2 = centerX + cos(ray.angle) * (ray.distance + 50);
		const y2 = centerY + sin(ray.angle) * (ray.distance + 50);

		// Only draw rays that are visible on screen
		const maxDistance = max(maxWidth, maxHeight);
		const drawDistance = maxDistance * 0.7;
		const shouldDraw = ray.distance < drawDistance;

		if (shouldDraw) {
			// Calculate opacity and thickness based on direction
			let opacityFactor, thicknessFactor;
			if (ray.reverse) {
				// For outward rays: start thick/opaque at center, fade as they move out
				opacityFactor = ray.opacity * (ray.distance / drawDistance);
				thicknessFactor = ray.thickness * (1 - ray.distance / drawDistance);
			} else {
				// For inward rays: start thin/faded far away, get thick/opaque as they approach
				opacityFactor = ray.opacity * (ray.distance / ray.startDistance);
				thicknessFactor = ray.thickness * (1 - ray.distance / ray.startDistance);
			}

			ctx.strokeStyle = ray.color;
			ctx.globalAlpha = Math.max(0, opacityFactor);
			ctx.lineWidth = Math.max(0.1, thicknessFactor);

			ctx.beginPath();
			ctx.moveTo(x1, y1);
			ctx.lineTo(x2, y2);
			ctx.stroke();

			// stroke(ray.color);
			// alpha(opacityFactor);
			// strokeWeight(thicknessFactor);
			// line(x1, y1, x2, y2);
		}

		// Move ray based on direction
		if (ray.reverse) {
			ray.distance += ray.speed; // Move outward from center
			// Reset ray if it gets too far
			if (ray.distance > maxDistance * 0.7) {
				rays[i] = createRay();
			}
		} else {
			ray.distance -= ray.speed; // Move toward viewer
			// Reset ray if it gets too close
			if (ray.distance < 0) {
				rays[i] = createRay();
			}
		}
	}
};

const drawGlow = function(){
	const centerX = maxWidth / 2;
	const centerY = maxHeight / 2;
	ctx.globalAlpha = 1.0;
	if (isFinite(centerX) && isFinite(centerY)) {
		const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 100);
		gradient.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
		gradient.addColorStop(0.5, 'rgba(74, 144, 226, 0.05)');
		gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
		ctx.fillStyle = gradient;
		ctx.fillRect(centerX - 100, centerY - 100, 200, 200);
		// fill(gradient);
		// rect(centerX - 100, centerY - 100, 200, 200);
	}
};

const changeDirection = function(){
	reverseDirection = !reverseDirection;
	for (let i = 0; i < rays.length; i++) {
		rays[i].reverse = reverseDirection;
	}
};

var draw = function(){
	background(colors.black);
	drawRays();
	drawGlow();
	drawStars();
};

var mouseClicked = function(){
	changeDirection();
};

var keyUp = function(e){
	// press 'r' to reverse direction!
	if (keycode.getKeyCode(e) === keys.R) {
		changeDirection();
	}
};

window.onload = function(){
	window.canvas = new Canvas(document.getElementById("canvas1"));
	window.ctx = canvas.ctx;
	canvas.setup = window.setup;
	canvas.draw = window.draw;
	canvas.run();
};
</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-42786295-1"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-42786295-1');
</script>
</body>
</html>
